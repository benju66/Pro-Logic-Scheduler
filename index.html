<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Logic Scheduler | V8.7</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/frappe-gantt/0.6.1/frappe-gantt.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/frappe-gantt/0.6.1/frappe-gantt.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        
        /* LAYOUT */
        .split-container { display: flex; height: calc(100vh - 56px); width: 100%; overflow: hidden; position: relative; }
        
        /* GRID PANE & COLUMNS */
        .grid-pane { 
            width: 45%; 
            min-width: 400px; 
            display: flex; 
            flex-direction: column; 
            background: white; 
            border-right: none;
            /* Default Widths */
            --w-chk: 30px; 
            --w-id: 30px;
            --w-name: 220px;
            --w-dur: 50px;
            --w-start: 110px; 
            --w-end: 95px;
            --w-constraint: 70px;
            --w-actions: 140px;
        }

        .resizer { width: 6px; cursor: col-resize; background: #f1f5f9; border-left: 1px solid #e2e8f0; border-right: 1px solid #e2e8f0; flex: 0 0 auto; z-index: 50; display: flex; align-items: center; justify-content: center; transition: background 0.2s; }
        .resizer:hover, .resizer.active { background: #cbd5e1; }
        .gantt-pane { flex: 1; min-width: 200px; overflow: auto; background: #f8fafc; position: relative; }

        /* GRID STYLES */
        .grid-header { 
            position: sticky; top: 0; background: #f8fafc; font-size: 11px; font-weight: 700; color: #64748b; text-transform: uppercase; z-index: 10; border-bottom: 1px solid #cbd5e1; height: 50px; display: flex; align-items: center; 
            min-width: fit-content; 
        }
        .grid-body { overflow-y: auto; flex: 1; overflow-x: auto; }
        
        .grid-row { display: flex; border-bottom: 1px solid #f1f5f9; height: 38px; align-items: center; font-size: 13px; background: white; min-width: fit-content; }
        .grid-row:hover { background-color: #f8fafc; }
        
        /* SELECTION MODE STYLES */
        .grid-row.row-selected {
            background-color: #f5f3ff !important; /* Light Indigo */
            box-shadow: inset 3px 0 0 0 #6366f1;   /* Indigo Marker */
        }
        .grid-row.row-selected .cell-input { background: transparent; }
        .select-checkbox {
            width: 14px; height: 14px; border-radius: 4px; cursor: pointer; accent-color: #6366f1;
        }

        /* COLUMNS */
        .col-cell {
            flex-shrink: 0;
            border-right: 1px solid #e2e8f0;
            height: 100%;
            display: flex;
            align-items: center;
            position: relative;
        }
        .col-resizer {
            width: 5px; cursor: col-resize; position: absolute; right: -2px; top: 0; bottom: 0; z-index: 20; background: transparent; transition: background 0.2s;
        }
        .col-resizer:hover, .col-resizer.active { background: #6366f1; }

        /* INPUTS & DRAG */
        .grid-row.sortable-ghost { background: #e0e7ff; opacity: 0.4; }
        .grid-row.sortable-drag { background: #fff; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); cursor: grabbing; opacity: 1 !important; }
        
        .cell-input { width: 100%; height: 100%; background: transparent; border: none; outline: none; padding: 0 8px; color: #334155; }
        .cell-input:focus { background: white; box-shadow: inset 0 0 0 2px #6366f1; }
        .cell-readonly { background: #f1f5f9; color: #94a3b8; font-style: italic; pointer-events: none; }
        select.cell-input { padding: 0 2px; appearance: none; text-align: center; font-weight: 600; }
        select.cell-input:not(:disabled):hover { background: #f1f5f9; }
        .drag-handle { cursor: grab; color: #94a3b8; }
        .drag-handle:active { cursor: grabbing; }

        /* SIDE DRAWER */
        .side-drawer {
            position: absolute; top: 0; right: -400px; width: 400px; height: 100%;
            background: white; border-left: 1px solid #cbd5e1; shadow: -5px 0 15px rgba(0,0,0,0.05);
            z-index: 100; transition: right 0.3s ease-in-out; display: flex; flex-direction: column;
        }
        .side-drawer.open { right: 0; box-shadow: -10px 0 25px -5px rgba(0, 0, 0, 0.1); }
        .drawer-header { padding: 16px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; background: #f8fafc; }
        .drawer-body { padding: 20px; overflow-y: auto; flex: 1; }
        .form-group { margin-bottom: 16px; }
        .form-label { display: block; font-size: 11px; font-weight: 700; color: #64748b; margin-bottom: 4px; text-transform: uppercase; }
        .form-input { width: 100%; border: 1px solid #cbd5e1; border-radius: 4px; padding: 8px; font-size: 13px; outline: none; transition: border-color 0.2s; }
        .form-input:focus { border-color: #6366f1; }

        /* GANTT OVERRIDES */
        .bar-wrapper.parent .bar { fill: #334155; height: 10px !important; transform: translateY(6px); opacity: 0.8; }
        .bar-wrapper .bar { fill: #93c5fd; rx: 2; ry: 2; }
        .bar-wrapper.critical .bar { fill: #f87171 !important; stroke: #dc2626; stroke-width: 1px; }
        .gantt-pane::-webkit-scrollbar { width: 8px; height: 8px; }
        .gantt-pane::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .gantt-pane::-webkit-scrollbar-corner { background: transparent; }
        .tab-btn { padding: 8px 16px; border-bottom: 2px solid transparent; color: #64748b; font-size: 13px; font-weight: 500; }
        .tab-btn.active { border-bottom-color: #0f172a; color: #0f172a; }
        
        /* Toast Notification */
        .toast {
            position: fixed; bottom: 20px; right: 20px; padding: 12px 20px;
            background: #1e293b; color: white; border-radius: 8px;
            font-size: 13px; z-index: 1000; opacity: 0;
            transform: translateY(10px); transition: all 0.3s ease;
        }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.error { background: #dc2626; }
        .toast.success { background: #059669; }
    </style>
</head>
<body class="bg-white text-slate-800 h-screen flex flex-col overflow-hidden">

    <header class="h-14 bg-white border-b border-gray-200 flex items-center justify-between px-4 flex-none z-20 shadow-sm">
        <div class="flex items-center gap-3">
            <div class="bg-purple-600 text-white p-1.5 rounded">
                <i data-lucide="maximize" class="w-5 h-5"></i>
            </div>
            <div>
                <h1 class="font-bold text-lg text-slate-800 leading-none">Pro Logic <span class="text-xs font-normal text-gray-400 ml-1">v8.7</span></h1>
                <p class="text-[10px] text-gray-500 font-medium">Double-Click for Details | ‚öì Anchored | ‚è∞ Deadline | ‚è≥ Wait | üîí Locked</p>
            </div>
        </div>

        <div class="flex items-center gap-2">
             <div class="flex items-center bg-gray-100 rounded p-1 gap-1">
                <button onclick="app.undo()" class="p-1 hover:bg-white rounded text-gray-600" title="Undo (Ctrl+Z)"><i data-lucide="undo-2" class="w-3 h-3"></i></button>
                <button onclick="app.redo()" class="p-1 hover:bg-white rounded text-gray-600" title="Redo (Ctrl+Y)"><i data-lucide="redo-2" class="w-3 h-3"></i></button>
                <div class="w-px h-3 bg-gray-300 mx-1"></div>
                <button onclick="app.downloadJSON()" class="text-xs font-bold px-2 py-1 hover:bg-white rounded text-gray-600 flex items-center gap-1" title="Save Backup"><i data-lucide="save" class="w-3 h-3"></i> Save</button>
                <button onclick="document.getElementById('file-upload').click()" class="text-xs font-bold px-2 py-1 hover:bg-white rounded text-gray-600 flex items-center gap-1" title="Load JSON or XML"><i data-lucide="upload" class="w-3 h-3"></i> Load</button>
                <div class="w-px h-3 bg-gray-300 mx-1"></div>
                <button onclick="app.exportToMSP()" class="text-xs font-bold px-2 py-1 hover:bg-white rounded text-emerald-700 flex items-center gap-1" title="Export to MS Project"><i data-lucide="file-spreadsheet" class="w-3 h-3"></i> XML</button>
            </div>
            <input type="file" id="file-upload" class="hidden" accept=".json,.xml" onchange="app.uploadFile(this)">

            <div class="h-6 w-px bg-gray-300 mx-2"></div>
            
            <button onclick="app.addTask()" class="flex items-center gap-2 bg-slate-800 hover:bg-slate-900 text-white px-3 py-1.5 rounded text-sm font-medium transition" title="Add to bottom">
                <i data-lucide="plus" class="w-4 h-4"></i> Add
            </button>
            
            <div class="h-6 w-px bg-gray-300 mx-2"></div>
            
            <div class="flex items-center bg-gray-100 rounded p-1">
                <button onclick="app.zoom('out')" class="p-1 hover:bg-white rounded text-gray-600" title="Zoom Out"><i data-lucide="minus" class="w-3 h-3"></i></button>
                <span id="zoom-label" class="text-[10px] font-bold px-2 text-gray-500 w-12 text-center">Week</span>
                <button onclick="app.zoom('in')" class="p-1 hover:bg-white rounded text-gray-600" title="Zoom In"><i data-lucide="plus" class="w-3 h-3"></i></button>
            </div>

            <button onclick="app.openPopout()" class="text-xs font-bold px-3 py-1.5 rounded bg-indigo-50 text-indigo-700 hover:bg-indigo-100 flex items-center gap-1 ml-2">
                <i data-lucide="external-link" class="w-3 h-3"></i> Popout
            </button>
        </div>
    </header>

    <div class="split-container" id="splitContainer">
        <div class="grid-pane" id="gridPane">
            <div class="grid-header">
                <div class="col-cell justify-center" style="width: var(--w-chk)">
                    <i data-lucide="check-square" class="w-3 h-3"></i>
                    <div class="col-resizer" onmousedown="app.startColResize(event, '--w-chk')"></div>
                </div>
                <div class="col-cell justify-center" style="width: var(--w-id)">
                    # <div class="col-resizer" onmousedown="app.startColResize(event, '--w-id')"></div>
                </div>
                <div class="col-cell px-2" style="width: var(--w-name)">
                    Task Name <div class="col-resizer" onmousedown="app.startColResize(event, '--w-name')"></div>
                </div>
                <div class="col-cell justify-center" style="width: var(--w-dur)">
                    Dur <div class="col-resizer" onmousedown="app.startColResize(event, '--w-dur')"></div>
                </div>
                <div class="col-cell px-2" style="width: var(--w-start)">
                    Start <div class="col-resizer" onmousedown="app.startColResize(event, '--w-start')"></div>
                </div>
                <div class="col-cell px-2" style="width: var(--w-end)">
                    Finish <div class="col-resizer" onmousedown="app.startColResize(event, '--w-end')"></div>
                </div>
                <div class="col-cell justify-center" style="width: var(--w-constraint)">
                    Constr <div class="col-resizer" onmousedown="app.startColResize(event, '--w-constraint')"></div>
                </div>
                <div class="col-cell justify-center" style="width: var(--w-actions)">
                    Actions
                </div>
            </div>
            
            <div id="grid-body" class="grid-body"></div>
        </div>
        <div class="resizer" id="resizer"></div>
        <div class="gantt-pane" id="ganttPane">
            <div id="gantt-chart" class="h-full"></div>
        </div>

        <div id="sideDrawer" class="side-drawer shadow-2xl">
            <div class="drawer-header">
                <h3 class="font-bold text-slate-800">Task Details</h3>
                <button onclick="app.closeDrawer()" class="text-gray-400 hover:text-gray-600"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
            <div class="drawer-body">
                <div class="form-group">
                    <label class="form-label">Task Name</label>
                    <input type="text" id="drawer-name" class="form-input" onchange="app.updateFromDrawer('name', this.value)">
                </div>
                <div class="form-group grid grid-cols-2 gap-2">
                    <div>
                        <label class="form-label">Duration (Days)</label>
                        <input type="number" id="drawer-duration" class="form-input" onchange="app.updateFromDrawer('duration', this.value)">
                    </div>
                    <div>
                         <label class="form-label">% Complete</label>
                         <input type="number" id="drawer-progress" class="form-input" onchange="app.updateFromDrawer('progress', this.value)">
                    </div>
                </div>

                <div class="my-4 border-t border-gray-100 pt-4">
                    <h4 class="font-bold text-xs text-slate-800 mb-3 uppercase tracking-wider">Constraints & Logic</h4>
                    
                    <div class="form-group">
                        <label class="form-label">Constraint Type</label>
                        <select id="drawer-constraintType" class="form-input bg-gray-50" onchange="app.updateFromDrawer('constraintType', this.value)">
                            <option value="asap">As Soon As Possible (Default)</option>
                            <optgroup label="Start Constraints">
                                <option value="snet">Start No Earlier Than (SNET)</option>
                                <option value="snlt">Start No Later Than (SNLT)</option>
                            </optgroup>
                            <optgroup label="Finish Constraints">
                                <option value="fnet">Finish No Earlier Than (FNET)</option>
                                <option value="fnlt">Finish No Later Than (FNLT)</option>
                                <option value="mfo">Must Finish On (MFO)</option>
                            </optgroup>
                        </select>
                        <p class="text-[10px] text-gray-500 mt-1" id="constraint-desc">Tasks flow naturally based on dependencies.</p>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Constraint Date</label>
                        <input type="date" id="drawer-constraintDate" class="form-input" onchange="app.updateFromDrawer('constraintDate', this.value)">
                    </div>
                </div>
            </div>
            <div class="p-4 bg-gray-50 border-t border-gray-200">
                <button onclick="app.deleteTask(app.activeTaskId); app.closeDrawer();" class="w-full text-red-600 bg-white border border-gray-300 hover:bg-red-50 font-medium text-xs py-2 rounded">Delete Task</button>
            </div>
        </div>
    </div>

    <dialog id="linkModal" class="rounded-lg shadow-2xl border border-gray-200 w-[500px] backdrop:bg-black/20 p-0 overflow-hidden">
        <div class="bg-gray-50 border-b border-gray-200 px-4 py-2 flex items-center justify-between">
            <h3 class="font-bold text-sm">Task Links</h3>
            <button onclick="document.getElementById('linkModal').close()" class="text-gray-400 hover:text-gray-600"><i data-lucide="x" class="w-4 h-4"></i></button>
        </div>
        <div class="flex border-b border-gray-200 bg-white">
            <button onclick="app.switchTab('pred')" id="tab-pred" class="tab-btn active w-1/2">Predecessors (Incoming)</button>
            <button onclick="app.switchTab('succ')" id="tab-succ" class="tab-btn w-1/2">Successors (Outgoing)</button>
        </div>
        <div class="p-4 bg-white h-[300px] overflow-y-auto">
            <div id="view-pred">
                <div class="flex gap-2 mb-3">
                    <select id="new-pred-select" class="flex-1 text-xs border border-gray-300 rounded p-1.5 focus:border-indigo-500 outline-none bg-white"></select>
                    <button onclick="app.addPredecessor()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded text-xs font-bold">Add Link</button>
                </div>
                <table class="w-full text-xs text-left">
                    <thead class="bg-gray-50 text-gray-500 border-b">
                        <tr><th class="p-2 font-medium">Task Name</th><th class="p-2 font-medium">Type</th><th class="p-2 font-medium w-16">Lag</th><th class="p-2 w-8"></th></tr>
                    </thead>
                    <tbody id="pred-list-body"></tbody>
                </table>
            </div>
            <div id="view-succ" class="hidden">
                <p class="text-xs text-gray-500 mb-2">Tasks waiting on this task:</p>
                <table class="w-full text-xs text-left">
                    <thead class="bg-gray-50 text-gray-500 border-b"><tr><th class="p-2 font-medium">Task Name</th><th class="p-2 font-medium">Relationship</th><th class="p-2 font-medium">Lag</th></tr></thead>
                    <tbody id="succ-list-body"></tbody>
                </table>
            </div>
        </div>
        <div class="bg-gray-50 p-3 flex justify-end gap-2 border-t border-gray-200">
            <button onclick="document.getElementById('linkModal').close()" class="px-3 py-1.5 text-xs font-medium bg-white border border-gray-300 rounded hover:bg-gray-50">Cancel</button>
            <button onclick="app.saveLinks()" class="px-3 py-1.5 text-xs font-medium bg-slate-800 text-white rounded hover:bg-slate-700">Save Logic</button>
        </div>
    </dialog>
    
    <!-- Toast Container -->
    <div id="toast" class="toast"></div>

<script>
    class ProScheduler {
        // ===== STATIC CONSTANTS =====
        static STORAGE_KEY = 'pro_scheduler_v8_7';
        static VIEW_OPTIONS = ['Day', 'Week', 'Month'];
        static LINK_TYPES = ['FS', 'SS', 'FF'];
        static MAX_HISTORY = 50;

        constructor() {
            this.tasks = [];
            this.history = []; 
            this.future = [];  
            this.clipboard = null;
            this.gantt = null;
            this.selectedTaskIds = new Set(); 
            this.lastFocusedTaskId = null;    
            this.anchorTaskId = null;         
            this.activeTaskId = null;         
            this.viewMode = 'Week';
            this.tempDependencies = [];
            this.init();
        }

        // ===== INITIALIZATION =====
        init() {
            this.loadData();
            this.recalculateAll(); 
            this.render();
            this.makeResizable();
            this.initScrollSync();
            this.initSortable(); 
            this.initKeyboardShortcuts();
            this.initEventDelegation();
            lucide.createIcons();
        }

        // ===== TOAST NOTIFICATIONS =====
        showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast ' + type;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // ===== DRAWER & CONSTRAINTS =====
        openDrawer(id) {
            if (this.activeTaskId === id && document.getElementById('sideDrawer').classList.contains('open')) {
                this.closeDrawer();
                return;
            }
            this.activeTaskId = id;
            const task = this.tasks.find(t => t.id === id);
            if (!task) return;
            document.getElementById('drawer-name').value = task.name;
            document.getElementById('drawer-duration').value = task.duration;
            document.getElementById('drawer-progress').value = task.progress || 0;
            document.getElementById('drawer-constraintType').value = task.constraintType || 'asap';
            document.getElementById('drawer-constraintDate').value = task.constraintDate || '';
            this.updateConstraintDesc(task.constraintType || 'asap');
            document.getElementById('sideDrawer').classList.add('open');
        }

        closeDrawer() {
            document.getElementById('sideDrawer').classList.remove('open');
            this.activeTaskId = null;
        }

        updateFromDrawer(field, value) {
            if (!this.activeTaskId) return;
            if (field === 'constraintType') { 
                this.updateConstraintDesc(value); 
            }
            this.update(this.activeTaskId, field, value);
        }

        updateConstraintDesc(type) {
            const el = document.getElementById('constraint-desc');
            const descriptions = {
                'asap': "Task flows naturally based on predecessors.",
                'snet': "Task cannot start before this date, but can start later if needed.",
                'snlt': "Task must start by this date. Creates conflict if dependencies push later.",
                'fnet': "Task cannot finish before this date. Useful for cure times, inspections.",
                'fnlt': "Task must finish by this date. Common for contract deadlines.",
                'mfo': "Task MUST finish exactly on this date. Hard constraint."
            };
            el.innerText = descriptions[type] || descriptions['asap'];
        }

        // ===== COLLAPSE/EXPAND =====
        toggleCollapse(id) {
            const task = this.tasks.find(t => t.id === id);
            if (task && this.isParent(id)) {
                task._collapsed = !task._collapsed;
                this.render();
            }
        }

        // ===== FILE OPERATIONS =====
        downloadJSON() {
            try {
                const data = JSON.stringify(this.tasks, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `pro_logic_schedule_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.showToast('Schedule saved successfully!', 'success');
            } catch (err) {
                this.showToast('Failed to save: ' + err.message, 'error');
            }
        }

        uploadFile(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    if (file.name.toLowerCase().endsWith('.json')) {
                        const parsed = JSON.parse(e.target.result);
                        if (!Array.isArray(parsed)) {
                            throw new Error('Invalid JSON format: expected an array of tasks');
                        }
                        // Validate basic structure
                        parsed.forEach((task, idx) => {
                            if (!task.id || !task.name) {
                                throw new Error(`Task at index ${idx} missing required fields (id, name)`);
                            }
                        });
                        this.saveCheckpoint();
                        this.tasks = parsed;
                        this.showToast(`Loaded ${parsed.length} tasks from JSON`, 'success');
                    } else if (file.name.toLowerCase().endsWith('.xml')) {
                        this.importFromMSP(e.target.result);
                    } else {
                        throw new Error('Unsupported file type. Use .json or .xml');
                    }
                    this.recalculateAll();
                    this.saveData();
                    this.render();
                } catch (err) {
                    this.showToast('Failed to load file: ' + err.message, 'error');
                    console.error('File load error:', err);
                }
            };
            reader.onerror = () => {
                this.showToast('Failed to read file', 'error');
            };
            reader.readAsText(file);
            input.value = ''; // Reset for re-upload
        }

        importFromMSP(xmlString) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
                
                // Check for parse errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    throw new Error('Invalid XML format');
                }
                
                const tasks = xmlDoc.querySelectorAll('Task');
                if (tasks.length === 0) {
                    throw new Error('No tasks found in XML');
                }
                
                const newTasks = [];
                const uidToId = new Map();
                
                tasks.forEach(taskEl => {
                    const uid = taskEl.querySelector('UID')?.textContent;
                    const name = taskEl.querySelector('Name')?.textContent;
                    const start = taskEl.querySelector('Start')?.textContent?.split('T')[0];
                    const finish = taskEl.querySelector('Finish')?.textContent?.split('T')[0];
                    const duration = taskEl.querySelector('Duration')?.textContent;
                    const outlineLevel = parseInt(taskEl.querySelector('OutlineLevel')?.textContent || '0');
                    
                    // Skip summary task (UID 0) if it exists
                    if (uid === '0' && name === '') return;
                    
                    const id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
                    uidToId.set(uid, id);
                    
                    // Parse duration (PT8H0M0S format)
                    let durationDays = 1;
                    if (duration) {
                        const match = duration.match(/PT(\d+)H/);
                        if (match) {
                            durationDays = Math.ceil(parseInt(match[1]) / 8);
                        }
                    }
                    
                    newTasks.push({
                        id,
                        uid,
                        name: name || 'Unnamed Task',
                        start: start || new Date().toISOString().split('T')[0],
                        end: finish || start || new Date().toISOString().split('T')[0],
                        duration: durationDays,
                        parentId: null,
                        outlineLevel,
                        dependencies: [],
                        progress: 0,
                        _collapsed: false
                    });
                });
                
                // Build hierarchy based on outline level
                for (let i = 0; i < newTasks.length; i++) {
                    const task = newTasks[i];
                    if (task.outlineLevel > 1) {
                        // Find parent (previous task with lower outline level)
                        for (let j = i - 1; j >= 0; j--) {
                            if (newTasks[j].outlineLevel < task.outlineLevel) {
                                task.parentId = newTasks[j].id;
                                break;
                            }
                        }
                    }
                    delete task.outlineLevel;
                    delete task.uid;
                }
                
                // Parse dependencies
                tasks.forEach(taskEl => {
                    const uid = taskEl.querySelector('UID')?.textContent;
                    const taskId = uidToId.get(uid);
                    if (!taskId) return;
                    
                    const task = newTasks.find(t => t.id === taskId);
                    if (!task) return;
                    
                    const predLinks = taskEl.querySelectorAll('PredecessorLink');
                    predLinks.forEach(link => {
                        const predUid = link.querySelector('PredecessorUID')?.textContent;
                        const predId = uidToId.get(predUid);
                        const linkType = link.querySelector('Type')?.textContent;
                        const lagValue = link.querySelector('LinkLag')?.textContent;
                        
                        if (predId) {
                            // MS Project link types: 0=FF, 1=FS, 2=SF, 3=SS
                            const typeMap = { '0': 'FF', '1': 'FS', '2': 'SF', '3': 'SS' };
                            task.dependencies.push({
                                id: predId,
                                type: typeMap[linkType] || 'FS',
                                lag: lagValue ? Math.round(parseInt(lagValue) / 4800) : 0 // Convert from tenths of minutes
                            });
                        }
                    });
                });
                
                this.saveCheckpoint();
                this.tasks = newTasks;
                this.showToast(`Imported ${newTasks.length} tasks from MS Project`, 'success');
            } catch (err) {
                throw new Error('XML import failed: ' + err.message);
            }
        }

        exportToMSP() {
            try {
                const today = new Date().toISOString();
                let xml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Project xmlns="http://schemas.microsoft.com/project">
    <Name>Pro Logic Export</Name>
    <CreationDate>${today}</CreationDate>
    <Tasks>`;

                this.tasks.forEach((task, index) => {
                    const uid = index + 1;
                    const startDate = task.start ? `${task.start}T08:00:00` : today;
                    const endDate = task.end ? `${task.end}T17:00:00` : today;
                    const durationHours = (task.duration || 1) * 8;
                    const outlineLevel = this.getDepth(task.id) + 1;
                    const isSummary = this.isParent(task.id);
                    
                    xml += `
        <Task>
            <UID>${uid}</UID>
            <ID>${uid}</ID>
            <Name>${this.escapeXml(task.name)}</Name>
            <Start>${startDate}</Start>
            <Finish>${endDate}</Finish>
            <Duration>PT${durationHours}H0M0S</Duration>
            <OutlineLevel>${outlineLevel}</OutlineLevel>
            <Summary>${isSummary ? 1 : 0}</Summary>
            <PercentComplete>${task.progress || 0}</PercentComplete>`;
                    
                    // Add predecessor links
                    if (task.dependencies && task.dependencies.length > 0) {
                        task.dependencies.forEach(dep => {
                            const predIndex = this.tasks.findIndex(t => t.id === dep.id);
                            if (predIndex !== -1) {
                                const typeMap = { 'FF': 0, 'FS': 1, 'SF': 2, 'SS': 3 };
                                const lagMinutes = (dep.lag || 0) * 8 * 60 * 10; // Convert days to tenths of minutes
                                xml += `
            <PredecessorLink>
                <PredecessorUID>${predIndex + 1}</PredecessorUID>
                <Type>${typeMap[dep.type] || 1}</Type>
                <LinkLag>${lagMinutes}</LinkLag>
            </PredecessorLink>`;
                            }
                        });
                    }
                    
                    xml += `
        </Task>`;
                });

                xml += `
    </Tasks>
</Project>`;

                const blob = new Blob([xml], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `pro_logic_export_${new Date().toISOString().split('T')[0]}.xml`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                this.showToast('Exported to MS Project XML!', 'success');
            } catch (err) {
                this.showToast('Export failed: ' + err.message, 'error');
            }
        }

        escapeXml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;')
                      .replace(/'/g, '&apos;');
        }

        // ===== CORE SCHEDULING LOGIC =====
        recalculateAll() {
            let changed = true;
            let loops = 0;
            const maxLoops = 50;
            
            while (changed && loops < maxLoops) {
                changed = false;
                loops++;
                
                this.tasks.forEach(t => {
                    if (this.isParent(t.id)) return; // Skip parents, calculated from children
                    
                    let dependencyStart = null;
                    
                    if (t.dependencies && t.dependencies.length > 0) {
                        const possibleStarts = [];
                        
                        t.dependencies.forEach(dep => {
                            const pred = this.tasks.find(x => x.id === dep.id);
                            if (pred && pred.start && pred.end) {
                                const lag = dep.lag || 0;
                                
                                if (dep.type === 'FS') {
                                    // Finish-to-Start: successor starts after predecessor ends
                                    possibleStarts.push(this.addWorkDays(pred.end, 1 + lag));
                                } else if (dep.type === 'SS') {
                                    // Start-to-Start: successor starts when predecessor starts
                                    possibleStarts.push(this.addWorkDays(pred.start, lag));
                                } else if (dep.type === 'FF') {
                                    // Finish-to-Finish: both finish together, so start = pred.end - duration + lag
                                    const startForFF = this.addWorkDays(pred.end, lag - t.duration + 1);
                                    possibleStarts.push(startForFF);
                                }
                            }
                        });
                        
                        if (possibleStarts.length > 0) {
                            possibleStarts.sort();
                            dependencyStart = possibleStarts[possibleStarts.length - 1]; // Latest start
                        }
                    }

                    const type = t.constraintType || 'asap';
                    const cDate = t.constraintDate;
                    
                    let finalStart = dependencyStart;
                    let finalEnd = null;
                    
                    // Handle different constraint types
                    switch (type) {
                        case 'snet':
                            // Start No Earlier Than - floor on start date
                            if (cDate) {
                                if (!finalStart || cDate > finalStart) {
                                    finalStart = cDate;
                                }
                            }
                            break;
                            
                        case 'snlt':
                            // Start No Later Than - ceiling on start date
                            if (cDate) {
                                if (!finalStart || finalStart > cDate) {
                                    finalStart = cDate;
                                }
                            }
                            break;
                            
                        case 'fnet':
                            // Finish No Earlier Than - floor on end date
                            // Calculate normal end first, then adjust if needed
                            if (cDate) {
                                if (!finalStart) finalStart = t.start || new Date().toISOString().split('T')[0];
                                const normalEnd = this.addWorkDays(finalStart, t.duration - 1);
                                if (normalEnd < cDate) {
                                    // Need to extend - push end to constraint date
                                    finalEnd = cDate;
                                    // Recalculate start to maintain duration
                                    finalStart = this.addWorkDays(cDate, -(t.duration - 1));
                                }
                            }
                            break;
                            
                        case 'fnlt':
                            // Finish No Later Than - ceiling on end date
                            if (cDate) {
                                if (!finalStart) finalStart = t.start || new Date().toISOString().split('T')[0];
                                const normalEnd = this.addWorkDays(finalStart, t.duration - 1);
                                if (normalEnd > cDate) {
                                    // Need to pull back - set end to constraint date
                                    finalEnd = cDate;
                                    // Recalculate start to maintain duration
                                    finalStart = this.addWorkDays(cDate, -(t.duration - 1));
                                }
                            }
                            break;
                            
                        case 'mfo':
                            // Must Finish On - hard constraint on end date
                            if (cDate) {
                                t.end = cDate;
                                t.start = this.addWorkDays(cDate, -(t.duration - 1));
                                return; // Skip normal calculation
                            }
                            break;
                            
                        case 'asap':
                        default:
                            // As Soon As Possible - no constraint
                            if (!finalStart && !t.start) {
                                finalStart = new Date().toISOString().split('T')[0];
                            }
                            break;
                    }
                    
                    if (!finalStart) finalStart = t.start;
                    
                    if (t.start !== finalStart) {
                        t.start = finalStart;
                        changed = true;
                    }
                    
                    if (t.start && t.duration >= 0) {
                        // Use finalEnd if set by constraint, otherwise calculate normally
                        const newEnd = finalEnd || this.addWorkDays(t.start, t.duration - 1);
                        if (t.end !== newEnd) {
                            t.end = newEnd;
                            changed = true;
                        }
                    }
                });

                // Calculate parent (summary) task dates from children
                this.tasks.forEach(p => {
                    if (!this.isParent(p.id)) return;
                    
                    const children = this.tasks.filter(c => c.parentId === p.id && c.start && c.end);
                    
                    if (children.length > 0) {
                        const starts = children.map(c => c.start).sort();
                        const ends = children.map(c => c.end).sort();
                        const minStart = starts[0];
                        const maxEnd = ends[ends.length - 1];
                        
                        if (p.start !== minStart || p.end !== maxEnd) {
                            p.start = minStart;
                            p.end = maxEnd;
                            p.duration = this.calcDurationWorkDays(minStart, maxEnd);
                            changed = true;
                        }
                    }
                });
            }
            
            this.calcCriticalPath();
        }

        update(id, field, value) {
            this.saveCheckpoint(); 
            const task = this.tasks.find(t => t.id === id);
            if (!task) return;
            
            switch (field) {
                case 'duration':
                    task.duration = Math.max(1, parseInt(value) || 1);
                    break;
                case 'name':
                    task.name = value;
                    break;
                case 'progress':
                    task.progress = Math.min(100, Math.max(0, parseInt(value) || 0));
                    break;
                case 'start':
                    if (value) {
                        task.constraintType = 'snet';
                        task.constraintDate = value;
                    }
                    break;
                case 'constraintType':
                    task.constraintType = value;
                    if (value === 'asap') {
                        task.constraintDate = '';
                    } else if (!task.constraintDate && value !== 'asap') {
                        // Auto-set constraint date based on type
                        if (value === 'snet' || value === 'snlt') {
                            task.constraintDate = task.start || new Date().toISOString().split('T')[0];
                        } else if (value === 'fnet' || value === 'fnlt' || value === 'mfo') {
                            task.constraintDate = task.end || new Date().toISOString().split('T')[0];
                        }
                    }
                    break;
                case 'constraintDate':
                    task.constraintDate = value;
                    break;
            }

            this.recalculateAll(); 
            this.saveData(); 
            
            // Check if we should re-render (avoid killing active input)
            const activeEl = document.activeElement;
            const isTypingInGrid = activeEl && activeEl.classList.contains('cell-input');
            
            if (!isTypingInGrid) {
                this.render();
            } else {
                // Only update Gantt when typing
                this.renderGantt();
            }
            
            // Sync drawer if open
            if (this.activeTaskId === id && document.getElementById('sideDrawer').classList.contains('open')) {
                this.syncDrawer(task);
            }
        }

        syncDrawer(task) {
            document.getElementById('drawer-name').value = task.name;
            document.getElementById('drawer-duration').value = task.duration;
            document.getElementById('drawer-progress').value = task.progress || 0;
            document.getElementById('drawer-constraintType').value = task.constraintType || 'asap';
            document.getElementById('drawer-constraintDate').value = task.constraintDate || '';
        }

        // ===== RENDER GRID =====
        renderGrid() {
            const container = document.getElementById('grid-body');
            container.innerHTML = '';
            const sorted = this.getFlatList();

            sorted.forEach((task, index) => {
                if (!this.isVisible(task.id)) return; 
                const depth = this.getDepth(task.id);
                const isParent = this.isParent(task.id);
                const padding = depth * 20;
                const isSelected = this.selectedTaskIds.has(task.id); 

                // Constraint icons - start constraints go in Start column, finish constraints in Finish column
                let startConstraintIcon = '';
                let finishConstraintIcon = '';
                let startPadding = '';
                let finishPadding = '';
                
                const cType = task.constraintType;
                const cDate = task.constraintDate || '';
                
                if (cType === 'snet') {
                    startConstraintIcon = `<i data-lucide="anchor" class="w-3 h-3 text-blue-500 absolute right-1 top-1/2 -translate-y-1/2 z-10 pointer-events-none" title="Start No Earlier Than ${cDate}"></i>`;
                    startPadding = 'pr-5';
                } else if (cType === 'snlt') {
                    startConstraintIcon = `<i data-lucide="alarm-clock" class="w-3 h-3 text-amber-500 absolute right-1 top-1/2 -translate-y-1/2 z-10 pointer-events-none" title="Start No Later Than ${cDate}"></i>`;
                    startPadding = 'pr-5';
                } else if (cType === 'fnet') {
                    finishConstraintIcon = `<i data-lucide="hourglass" class="w-3 h-3 text-blue-500 absolute right-1 top-1/2 -translate-y-1/2 z-10 pointer-events-none" title="Finish No Earlier Than ${cDate}"></i>`;
                    finishPadding = 'pr-5';
                } else if (cType === 'fnlt') {
                    finishConstraintIcon = `<i data-lucide="alarm-clock" class="w-3 h-3 text-amber-500 absolute right-1 top-1/2 -translate-y-1/2 z-10 pointer-events-none" title="Finish No Later Than ${cDate}"></i>`;
                    finishPadding = 'pr-5';
                } else if (cType === 'mfo') {
                    finishConstraintIcon = `<i data-lucide="lock" class="w-3 h-3 text-red-500 absolute right-1 top-1/2 -translate-y-1/2 z-10 pointer-events-none" title="Must Finish On ${cDate}"></i>`;
                    finishPadding = 'pr-5';
                }

                let collapseBtn = `<span class="w-5 inline-block"></span>`;
                if (isParent) {
                    const icon = task._collapsed ? 'chevron-right' : 'chevron-down';
                    collapseBtn = `<button data-action="collapse" data-task-id="${task.id}" class="w-5 h-5 flex items-center justify-center hover:bg-gray-100 rounded text-gray-500 mr-1"><i data-lucide="${icon}" class="w-3 h-3"></i></button>`;
                }

                let actions = `<div class="flex items-center justify-center gap-1">`;
                actions += `<button data-action="outdent" data-task-id="${task.id}" class="p-1 text-gray-400 hover:text-slate-800 rounded hover:bg-slate-100" title="Outdent"><i data-lucide="outdent" class="w-3 h-3"></i></button>`;
                actions += `<button data-action="indent" data-task-id="${task.id}" class="p-1 text-gray-400 hover:text-slate-800 rounded hover:bg-slate-100" title="Indent"><i data-lucide="indent" class="w-3 h-3"></i></button>`;
                if (!isParent) {
                    actions += `<button data-action="links" data-task-id="${task.id}" class="p-1 text-gray-400 hover:text-indigo-600 rounded hover:bg-indigo-50 ml-1" title="Dependencies"><i data-lucide="link" class="w-3 h-3"></i></button>`;
                }
                actions += `<button data-action="delete" data-task-id="${task.id}" class="p-1 text-gray-400 hover:text-red-600 rounded hover:bg-red-50 ml-1" title="Delete"><i data-lucide="trash-2" class="w-3 h-3"></i></button>`;
                actions += `</div>`;

                container.innerHTML += `
                    <div class="grid-row group ${isParent ? 'bg-slate-50' : ''} ${isSelected ? 'row-selected' : ''}" 
                         data-id="${task.id}"
                         onclick="app.handleRowClick(event, '${task.id}')"
                         ondblclick="app.openDrawer('${task.id}')">
                        <div class="col-cell justify-center" style="width: var(--w-chk)">
                            <input type="checkbox" class="select-checkbox" ${isSelected ? 'checked' : ''} style="pointer-events:none;">
                        </div>
                        <div class="col-cell justify-center text-gray-400 text-[10px] drag-handle transition-colors h-full" style="width: var(--w-id)">
                            ${index + 1}
                        </div>
                        <div class="col-cell px-2 relative overflow-hidden" style="width: var(--w-name)">
                            <div style="width: ${padding}px" class="flex-none border-r border-dashed border-gray-300 h-full mr-2"></div>
                            ${collapseBtn}
                            <input value="${this.escapeHtml(task.name)}" 
                                data-field="name" 
                                data-task-id="${task.id}"
                                class="cell-input font-medium ${isParent ? 'font-bold' : ''}" 
                            >
                        </div>
                        <div class="col-cell" style="width: var(--w-dur)">
                            <input type="number" value="${task.duration}" 
                                data-field="duration" 
                                data-task-id="${task.id}"
                                class="cell-input text-center ${isParent ? 'cell-readonly' : ''}" 
                                ${isParent ? 'readonly' : ''}>
                        </div>
                        <div class="col-cell relative" style="width: var(--w-start)">
                            <input type="date" value="${task.start || ''}" 
                                data-field="start" 
                                data-task-id="${task.id}"
                                class="cell-input text-xs ${startPadding} ${isParent ? 'cell-readonly' : ''}" 
                                ${isParent ? 'readonly' : ''}>
                            ${startConstraintIcon}
                        </div>
                        <div class="col-cell relative" style="width: var(--w-end)">
                            <input type="date" value="${task.end || ''}" readonly class="cell-input text-xs cell-readonly ${finishPadding}">
                            ${finishConstraintIcon}
                        </div>
                        <div class="col-cell" style="width: var(--w-constraint)">
                            <select 
                                data-field="constraintType" 
                                data-task-id="${task.id}"
                                class="cell-input text-[10px] bg-transparent cursor-pointer ${isParent ? 'cell-readonly' : ''}"
                                ${isParent ? 'disabled' : ''}
                                title="Constraint Type">
                                <option value="asap" ${(task.constraintType || 'asap') === 'asap' ? 'selected' : ''}>ASAP</option>
                                <option value="snet" ${task.constraintType === 'snet' ? 'selected' : ''}>SNET</option>
                                <option value="snlt" ${task.constraintType === 'snlt' ? 'selected' : ''}>SNLT</option>
                                <option value="fnet" ${task.constraintType === 'fnet' ? 'selected' : ''}>FNET</option>
                                <option value="fnlt" ${task.constraintType === 'fnlt' ? 'selected' : ''}>FNLT</option>
                                <option value="mfo" ${task.constraintType === 'mfo' ? 'selected' : ''}>MFO</option>
                            </select>
                        </div>
                        <div class="col-cell justify-center" style="width: var(--w-actions)">${actions}</div>
                    </div>
                `;
            });
        }

        escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;');
        }

        // ===== EVENT DELEGATION =====
        initEventDelegation() {
            const gridBody = document.getElementById('grid-body');
            
            // Handle action button clicks via delegation
            gridBody.addEventListener('click', (e) => {
                const actionBtn = e.target.closest('[data-action]');
                if (actionBtn) {
                    e.stopPropagation(); // Prevent row click
                    const action = actionBtn.dataset.action;
                    const btnTaskId = actionBtn.dataset.taskId;
                    
                    switch (action) {
                        case 'collapse':
                            this.toggleCollapse(btnTaskId);
                            break;
                        case 'indent':
                            this.indent(btnTaskId);
                            break;
                        case 'outdent':
                            this.outdent(btnTaskId);
                            break;
                        case 'links':
                            this.openLinks(btnTaskId);
                            break;
                        case 'delete':
                            this.deleteTask(btnTaskId);
                            break;
                    }
                }
            });
            
            // Handle input changes via delegation (blur for text/date inputs)
            gridBody.addEventListener('blur', (e) => {
                if (e.target.classList.contains('cell-input') && e.target.dataset.field && e.target.tagName !== 'SELECT') {
                    const field = e.target.dataset.field;
                    const taskId = e.target.dataset.taskId;
                    this.update(taskId, field, e.target.value);
                }
            }, true); // Use capture phase for blur
            
            // Handle select changes via delegation (change event for dropdowns)
            gridBody.addEventListener('change', (e) => {
                if (e.target.classList.contains('cell-input') && e.target.dataset.field && e.target.tagName === 'SELECT') {
                    const field = e.target.dataset.field;
                    const taskId = e.target.dataset.taskId;
                    this.update(taskId, field, e.target.value);
                }
            });
            
            // Handle Enter key in inputs
            gridBody.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.target.classList.contains('cell-input')) {
                    e.target.blur();
                }
            });
        }

        // ===== HISTORY (UNDO/REDO) =====
        saveCheckpoint() {
            const snapshot = JSON.stringify(this.tasks);
            if (this.history.length > 0 && this.history[this.history.length - 1] === snapshot) return;
            this.history.push(snapshot);
            if (this.history.length > ProScheduler.MAX_HISTORY) {
                this.history.shift();
            }
            this.future = [];
        }

        undo() {
            if (this.history.length === 0) {
                this.showToast('Nothing to undo', 'info');
                return;
            }
            this.future.push(JSON.stringify(this.tasks));
            const previousState = this.history.pop();
            this.tasks = JSON.parse(previousState);
            this.recalculateAll();
            this.saveData();
            this.render();
            this.showToast('Undone', 'info');
        }

        redo() {
            if (this.future.length === 0) {
                this.showToast('Nothing to redo', 'info');
                return;
            }
            this.history.push(JSON.stringify(this.tasks));
            const nextState = this.future.pop();
            this.tasks = JSON.parse(nextState);
            this.recalculateAll();
            this.saveData();
            this.render();
            this.showToast('Redone', 'info');
        }

        // ===== COPY/PASTE =====
        copySelection() {
            const selected = this.tasks.filter(t => this.selectedTaskIds.has(t.id));
            if (selected.length === 0) {
                this.showToast('No tasks selected', 'info');
                return;
            }
            
            const payload = new Set();
            const getDescendants = (parentId) => {
                this.tasks.filter(t => t.parentId === parentId).forEach(child => {
                    payload.add(child);
                    getDescendants(child.id);
                });
            };
            
            selected.forEach(task => {
                payload.add(task);
                if (this.isParent(task.id)) {
                    getDescendants(task.id);
                }
            });
            
            this.clipboard = Array.from(payload)
                .sort((a, b) => this.tasks.indexOf(a) - this.tasks.indexOf(b));
            this.clipboard = JSON.parse(JSON.stringify(this.clipboard));
            this.showToast(`Copied ${this.clipboard.length} task(s)`, 'success');
        }

        pasteTasks() {
            if (!this.clipboard || this.clipboard.length === 0) {
                this.showToast('Nothing to paste', 'info');
                return;
            }
            
            this.saveCheckpoint();
            const targetId = this.lastFocusedTaskId;
            let targetIndex = targetId ? this.tasks.findIndex(t => t.id === targetId) : this.tasks.length - 1;
            if (targetIndex === -1) targetIndex = this.tasks.length - 1;
            
            const targetTask = this.tasks[targetIndex];
            const targetParentId = targetTask ? targetTask.parentId : null;
            
            const idMap = new Map();
            const newTasks = [];
            
            this.clipboard.forEach(task => {
                const newId = Date.now() + Math.random().toString().slice(2, 8);
                idMap.set(task.id, newId);
                const newTask = JSON.parse(JSON.stringify(task));
                newTask.id = newId;
                newTasks.push(newTask);
            });
            
            newTasks.forEach(task => {
                const oldPid = task.parentId;
                if (oldPid && idMap.has(oldPid)) {
                    task.parentId = idMap.get(oldPid);
                } else {
                    task.parentId = targetParentId;
                }
                task.dependencies = task.dependencies.map(dep => {
                    if (idMap.has(dep.id)) {
                        return { ...dep, id: idMap.get(dep.id) };
                    }
                    return dep;
                }).filter(dep => idMap.has(dep.id) || this.tasks.some(t => t.id === dep.id));
            });
            
            this.tasks.splice(targetIndex + 1, 0, ...newTasks);
            this.selectedTaskIds.clear();
            newTasks.forEach(t => this.selectedTaskIds.add(t.id));
            this.recalculateAll();
            this.saveData();
            this.render();
            this.showToast(`Pasted ${newTasks.length} task(s)`, 'success');
        }

        // ===== KEYBOARD SHORTCUTS =====
        initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        }

        handleKeyDown(e) {
            const isEditing = e.target.classList.contains('cell-input') || 
                              e.target.classList.contains('form-input');
            const isCtrl = e.ctrlKey || e.metaKey;

            // Undo/Redo (works even when editing)
            if (isCtrl && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                this.undo();
                return;
            }
            if ((isCtrl && e.key === 'y') || (isCtrl && e.shiftKey && e.key === 'z')) {
                e.preventDefault();
                this.redo();
                return;
            }

            // Skip other shortcuts when editing
            if (isEditing) {
                if (e.key === 'Escape') {
                    e.target.blur();
                }
                return;
            }

            // Copy/Paste
            if (isCtrl && e.key === 'c') {
                e.preventDefault();
                this.copySelection();
                return;
            }
            if (isCtrl && e.key === 'v') {
                e.preventDefault();
                this.pasteTasks();
                return;
            }

            // F2 to edit
            if (e.key === 'F2' && this.lastFocusedTaskId) {
                e.preventDefault();
                this.enterEditMode();
                return;
            }

            // Insert to add task above
            if (e.key === 'Insert') {
                e.preventDefault();
                this.insertTaskAbove();
                return;
            }

            // Ctrl+Arrow to move tasks
            if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && isCtrl) {
                e.preventDefault();
                this.moveTaskVertical(e.key === 'ArrowUp' ? -1 : 1);
                return;
            }

            // Tab for indent/outdent
            if (e.key === 'Tab' && this.selectedTaskIds.size > 0) {
                e.preventDefault();
                if (e.shiftKey) this.outdentSelection();
                else this.indentSelection();
                return;
            }

            // Arrow navigation
            if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && !isCtrl) {
                e.preventDefault();
                this.handleArrowNavigation(e.key === 'ArrowUp' ? -1 : 1, e.shiftKey);
                return;
            }

            // Collapse/expand with arrow keys
            if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && this.lastFocusedTaskId) {
                const task = this.tasks.find(t => t.id === this.lastFocusedTaskId);
                if (task && this.isParent(task.id)) {
                    e.preventDefault();
                    if (e.key === 'ArrowRight' && task._collapsed) {
                        task._collapsed = false;
                        this.render();
                    } else if (e.key === 'ArrowLeft' && !task._collapsed) {
                        task._collapsed = true;
                        this.render();
                    }
                }
                return;
            }

            // Escape to deselect or close drawer
            if (e.key === 'Escape') {
                if (document.getElementById('sideDrawer').classList.contains('open')) {
                    this.closeDrawer();
                } else {
                    this.deselectAll();
                }
                return;
            }

            // Delete selected tasks
            if ((e.key === 'Delete' || e.key === 'Backspace') && this.selectedTaskIds.size > 0) {
                e.preventDefault();
                this.deleteSelectedTasks();
            }
        }

        enterEditMode() {
            const row = document.querySelector(`.grid-row[data-id="${this.lastFocusedTaskId}"]`);
            if (!row) return;
            const input = row.querySelector('.cell-input[data-field="name"]');
            if (input) {
                input.focus();
                input.select();
            }
        }

        insertTaskAbove() {
            this.saveCheckpoint();
            if (!this.lastFocusedTaskId) {
                this.addTask();
                return;
            }
            
            const targetIndex = this.tasks.findIndex(t => t.id === this.lastFocusedTaskId);
            if (targetIndex === -1) return;
            
            const targetTask = this.tasks[targetIndex];
            const newId = Date.now().toString();
            const today = new Date().toISOString().split('T')[0];
            
            const newTask = {
                id: newId,
                name: "New Task",
                start: today,
                end: today,
                duration: 1,
                parentId: targetTask.parentId,
                dependencies: [],
                progress: 0,
                _collapsed: false
            };
            
            this.tasks.splice(targetIndex, 0, newTask);
            this.recalculateAll();
            this.saveData();
            this.render();
            
            this.lastFocusedTaskId = newId;
            this.selectedTaskIds.clear();
            this.selectedTaskIds.add(newId);
            this.renderGrid();
            this.scrollToRow(newId);
        }

        handleArrowNavigation(direction, isShift) {
            const visibleTasks = this.getFlatList().filter(t => this.isVisible(t.id));
            if (visibleTasks.length === 0) return;
            
            let currentIndex = visibleTasks.findIndex(t => t.id === this.lastFocusedTaskId);
            if (currentIndex === -1) currentIndex = 0;
            
            let newIndex = currentIndex + direction;
            newIndex = Math.max(0, Math.min(visibleTasks.length - 1, newIndex));
            
            const targetTask = visibleTasks[newIndex];
            this.lastFocusedTaskId = targetTask.id;
            
            if (!isShift) {
                this.anchorTaskId = targetTask.id;
                this.selectedTaskIds.clear();
                this.selectedTaskIds.add(targetTask.id);
            } else {
                if (!this.anchorTaskId) this.anchorTaskId = visibleTasks[currentIndex].id;
                const anchorIndex = visibleTasks.findIndex(t => t.id === this.anchorTaskId);
                const start = Math.min(anchorIndex, newIndex);
                const end = Math.max(anchorIndex, newIndex);
                this.selectedTaskIds.clear();
                for (let i = start; i <= end; i++) {
                    this.selectedTaskIds.add(visibleTasks[i].id);
                }
            }
            
            this.renderGrid();
            lucide.createIcons();
            this.scrollToRow(targetTask.id);
        }

        handleRowClick(e, id) {
            // Skip if clicking on input or button
            if (e.target.classList.contains('cell-input') || e.target.closest('button')) {
                return;
            }
            
            const visibleTasks = this.getFlatList().filter(t => this.isVisible(t.id));
            const clickedIndex = visibleTasks.findIndex(t => t.id === id);
            this.lastFocusedTaskId = id;
            
            if (e.shiftKey && this.anchorTaskId) {
                const anchorIndex = visibleTasks.findIndex(t => t.id === this.anchorTaskId);
                const start = Math.min(anchorIndex, clickedIndex);
                const end = Math.max(anchorIndex, clickedIndex);
                this.selectedTaskIds.clear();
                for (let i = start; i <= end; i++) {
                    this.selectedTaskIds.add(visibleTasks[i].id);
                }
            } else if (e.ctrlKey || e.metaKey) {
                if (this.selectedTaskIds.has(id)) {
                    this.selectedTaskIds.delete(id);
                } else {
                    this.selectedTaskIds.add(id);
                    this.anchorTaskId = id;
                }
            } else {
                this.selectedTaskIds.clear();
                this.selectedTaskIds.add(id);
                this.anchorTaskId = id;
            }
            
            this.renderGrid();
            lucide.createIcons();
        }

        scrollToRow(id) {
            const row = document.querySelector(`.grid-row[data-id="${id}"]`);
            if (row) row.scrollIntoView({ block: 'nearest', behavior: 'auto' });
        }

        deselectAll() {
            this.selectedTaskIds.clear();
            this.renderGrid();
            lucide.createIcons();
        }

        moveTaskVertical(direction) {
            if (!this.lastFocusedTaskId) return;
            this.saveCheckpoint();
            
            const task = this.tasks.find(t => t.id === this.lastFocusedTaskId);
            if (!task) return;
            
            const siblings = this.tasks.filter(t => t.parentId === task.parentId);
            const currentSiblingIndex = siblings.findIndex(t => t.id === task.id);
            if (currentSiblingIndex === -1) return;
            
            const targetSiblingIndex = currentSiblingIndex + direction;
            if (targetSiblingIndex < 0 || targetSiblingIndex >= siblings.length) return;
            
            const siblingTarget = siblings[targetSiblingIndex];
            const indexA = this.tasks.indexOf(task);
            const indexB = this.tasks.indexOf(siblingTarget);
            
            if (indexA > -1 && indexB > -1) {
                [this.tasks[indexA], this.tasks[indexB]] = [this.tasks[indexB], this.tasks[indexA]];
                this.saveData();
                this.render();
                this.scrollToRow(this.lastFocusedTaskId);
            }
        }

        // ===== SCROLL SYNC =====
        initScrollSync() {
            const grid = document.getElementById('grid-body');
            const gantt = document.getElementById('ganttPane');
            let isSyncingLeft = false;
            let isSyncingRight = false;
            
            grid.onscroll = function() {
                if (!isSyncingLeft) {
                    isSyncingRight = true;
                    gantt.scrollTop = this.scrollTop;
                }
                isSyncingLeft = false;
            };
            
            gantt.onscroll = function() {
                if (!isSyncingRight) {
                    isSyncingLeft = true;
                    grid.scrollTop = this.scrollTop;
                }
                isSyncingRight = false;
            };
        }

        // ===== SORTABLE (DRAG & DROP) =====
        initSortable() {
            const el = document.getElementById('grid-body');
            if (typeof Sortable === 'undefined') return;
            
            this.sortable = Sortable.create(el, {
                animation: 150,
                handle: '.drag-handle',
                ghostClass: 'sortable-ghost',
                dragClass: 'sortable-drag',
                onEnd: (evt) => {
                    const { oldIndex, newIndex } = evt;
                    if (oldIndex === newIndex) return;
                    
                    this.saveCheckpoint();
                    
                    // Get visible tasks in display order
                    const visibleTasks = this.getFlatList().filter(t => this.isVisible(t.id));
                    const movedTask = visibleTasks[oldIndex];
                    
                    if (!movedTask) {
                        this.render();
                        return;
                    }
                    
                    // Remove from current position in main tasks array
                    const originalIndex = this.tasks.findIndex(t => t.id === movedTask.id);
                    if (originalIndex === -1) {
                        this.render();
                        return;
                    }
                    
                    this.tasks.splice(originalIndex, 1);
                    
                    // Determine new parent and position
                    let newParentId = null;
                    let insertIndex;
                    
                    if (newIndex === 0) {
                        // Moving to top
                        insertIndex = 0;
                        newParentId = null;
                    } else {
                        // Get the task above the new position (after removal)
                        const tasksAbove = visibleTasks.filter((t, i) => i < newIndex && t.id !== movedTask.id);
                        const taskAbove = tasksAbove[tasksAbove.length - 1];
                        
                        if (taskAbove) {
                            // Keep same parent level as the task we're now adjacent to
                            newParentId = taskAbove.parentId;
                            
                            // Find where to insert in the main array
                            const taskAboveIndex = this.tasks.findIndex(t => t.id === taskAbove.id);
                            insertIndex = taskAboveIndex + 1;
                            
                            // If taskAbove is a parent and not collapsed, insert after its children
                            if (this.isParent(taskAbove.id) && !taskAbove._collapsed) {
                                const getLastDescendantIndex = (parentId) => {
                                    let lastIndex = this.tasks.findIndex(t => t.id === parentId);
                                    this.tasks.forEach((t, idx) => {
                                        if (t.parentId === parentId) {
                                            const descIndex = getLastDescendantIndex(t.id);
                                            if (descIndex > lastIndex) lastIndex = descIndex;
                                        }
                                    });
                                    return lastIndex;
                                };
                                insertIndex = getLastDescendantIndex(taskAbove.id) + 1;
                            }
                        } else {
                            insertIndex = 0;
                        }
                    }
                    
                    movedTask.parentId = newParentId;
                    this.tasks.splice(insertIndex, 0, movedTask);
                    
                    this.recalculateAll();
                    this.saveData();
                    this.render();
                }
            });
        }

        // ===== ZOOM =====
        zoom(direction) {
            const idx = ProScheduler.VIEW_OPTIONS.indexOf(this.viewMode);
            if (direction === 'in' && idx > 0) {
                this.changeView(ProScheduler.VIEW_OPTIONS[idx - 1]);
            } else if (direction === 'out' && idx < ProScheduler.VIEW_OPTIONS.length - 1) {
                this.changeView(ProScheduler.VIEW_OPTIONS[idx + 1]);
            }
        }

        changeView(mode) {
            this.viewMode = mode;
            document.getElementById('zoom-label').innerText = mode;
            if (this.gantt) this.gantt.change_view_mode(mode);
        }

        // ===== POPOUT =====
        openPopout() {
            const win = window.open('', 'ProLogicGantt', 'width=1200,height=800,menubar=no,toolbar=no');
            if (!win) {
                this.showToast('Popup blocked by browser', 'error');
                return;
            }
            
            const tasksJson = JSON.stringify(
                this.tasks.filter(t => t.start && t.end && this.isVisible(t.id)).map(t => ({
                    id: t.id,
                    name: t.name,
                    start: t.start,
                    end: t.end,
                    progress: t.progress,
                    dependencies: t.dependencies.map(d => d.id).join(", "),
                    custom_class: (this.isParent(t.id) ? 'parent' : '') + (t._isCritical ? ' critical' : '')
                }))
            );
            
            const html = `<!DOCTYPE html>
<html>
<head>
    <title>Pro Logic Detached View</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/frappe-gantt/0.6.1/frappe-gantt.min.js"><\/script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/frappe-gantt/0.6.1/frappe-gantt.css">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; padding: 20px; background: #f8fafc; }
        h3 { margin-bottom: 20px; color: #1e293b; }
        .bar-wrapper.parent .bar { fill: #334155; height: 10px; opacity: 0.8; }
        .bar-wrapper .bar { fill: #93c5fd; }
        .bar-wrapper.critical .bar { fill: #f87171; stroke: #dc2626; }
    </style>
</head>
<body>
    <h3>Pro Logic Scheduler - Detached Gantt View</h3>
    <svg id="gantt"></svg>
    <script>
        new Gantt("#gantt", ${tasksJson}, {
            header_height: 50,
            column_width: 30,
            view_modes: ['Day', 'Week', 'Month'],
            bar_height: 20,
            view_mode: 'Week'
        });
    <\/script>
</body>
</html>`;
            win.document.write(html);
            win.document.close();
        }

        // ===== DATA PERSISTENCE =====
        loadData() {
            try {
                const stored = localStorage.getItem(ProScheduler.STORAGE_KEY);
                if (stored) {
                    this.tasks = JSON.parse(stored);
                    // Validate loaded data
                    if (!Array.isArray(this.tasks)) {
                        throw new Error('Invalid data format');
                    }
                } else {
                    // Try to migrate from old version
                    const oldData = localStorage.getItem('pro_v7_9_data');
                    if (oldData) {
                        this.tasks = JSON.parse(oldData);
                        this.saveData(); // Save to new key
                        localStorage.removeItem('pro_v7_9_data'); // Clean up old key
                    } else {
                        this.createSampleData();
                    }
                }
            } catch (err) {
                console.error('Failed to load data:', err);
                this.createSampleData();
            }
        }

        createSampleData() {
            const fri = this.getNextDayOfWeek(5);
            this.tasks = [
                {
                    id: "1",
                    name: "Structure Phase",
                    start: "",
                    end: "",
                    duration: 0,
                    parentId: null,
                    dependencies: [],
                    progress: 0,
                    _collapsed: false
                },
                {
                    id: "2",
                    name: "Framing",
                    start: fri,
                    end: "",
                    duration: 3,
                    parentId: "1",
                    dependencies: [],
                    progress: 0
                },
                {
                    id: "3",
                    name: "Sheathing",
                    start: "",
                    end: "",
                    duration: 2,
                    parentId: "1",
                    dependencies: [{ id: "2", type: "FS", lag: 0 }],
                    progress: 0
                }
            ];
        }

        saveData() {
            try {
                localStorage.setItem(ProScheduler.STORAGE_KEY, JSON.stringify(this.tasks));
            } catch (err) {
                this.showToast('Failed to save data: ' + err.message, 'error');
            }
        }

        // ===== DATE UTILITIES =====
        addWorkDays(startDateStr, days) {
            if (!startDateStr) return "";
            
            let date = new Date(startDateStr + 'T12:00:00'); // Noon to avoid timezone issues
            
            if (days === 0) return startDateStr;
            
            const direction = days >= 0 ? 1 : -1;
            let remaining = Math.abs(days);
            
            while (remaining > 0) {
                date.setDate(date.getDate() + direction);
                const day = date.getDay();
                if (day !== 0 && day !== 6) remaining--;
            }
            
            return date.toISOString().split('T')[0];
        }

        calcDurationWorkDays(startStr, endStr) {
            if (!startStr || !endStr) return 0;
            
            let current = new Date(startStr + 'T12:00:00');
            let end = new Date(endStr + 'T12:00:00');
            
            if (current > end) return 0;
            if (current.getTime() === end.getTime()) return 1; // Same day = 1 day duration
            
            let count = 1; // Include start day
            while (current < end) {
                current.setDate(current.getDate() + 1);
                const day = current.getDay();
                if (day !== 0 && day !== 6) count++;
            }
            
            return count;
        }

        getNextDayOfWeek(dayIndex) {
            const d = new Date();
            d.setDate(d.getDate() + (7 + dayIndex - d.getDay()) % 7);
            return d.toISOString().split('T')[0];
        }

        // ===== CRITICAL PATH =====
        calcCriticalPath() {
            // Reset all critical flags
            this.tasks.forEach(t => t._isCritical = false);
            
            // Find project end date
            const validEnds = this.tasks.filter(t => t.end && !this.isParent(t.id)).map(t => t.end);
            if (validEnds.length === 0) return;
            
            const projectEnd = validEnds.sort().reverse()[0];
            
            // Calculate total float for each task
            // Tasks with zero float are on critical path
            const taskFloats = new Map();
            
            // Simple approach: tasks ending on project end date with no successors are critical
            // Then trace back through their predecessors
            const markCritical = (task) => {
                if (task._isCritical) return;
                task._isCritical = true;
                
                // Mark predecessors as critical
                if (task.dependencies) {
                    task.dependencies.forEach(dep => {
                        const pred = this.tasks.find(x => x.id === dep.id);
                        if (pred) markCritical(pred);
                    });
                }
                
                // Mark parent as critical
                if (task.parentId) {
                    const parent = this.tasks.find(x => x.id === task.parentId);
                    if (parent) parent._isCritical = true;
                }
            };
            
            // Find tasks that end on the project end date and have no successors
            this.tasks.forEach(t => {
                if (t.end === projectEnd && !this.isParent(t.id)) {
                    // Check if this task has any successors
                    const hasSuccessors = this.tasks.some(other => 
                        other.dependencies && other.dependencies.some(d => d.id === t.id)
                    );
                    
                    // If no successors, this is an end task
                    if (!hasSuccessors) {
                        markCritical(t);
                    }
                }
            });
            
            // If nothing marked (circular deps or other issues), mark tasks ending on project end
            const anyMarked = this.tasks.some(t => t._isCritical);
            if (!anyMarked) {
                this.tasks.filter(t => t.end === projectEnd).forEach(t => markCritical(t));
            }
        }

        // ===== HIERARCHY HELPERS =====
        isParent(id) {
            return this.tasks.some(t => t.parentId === id);
        }

        isVisible(taskId) {
            let curr = this.tasks.find(t => t.id === taskId);
            while (curr && curr.parentId) {
                const parent = this.tasks.find(p => p.id === curr.parentId);
                if (parent && parent._collapsed) return false;
                curr = parent;
            }
            return true;
        }

        getFlatList() {
            const res = [];
            const add = (pid) => {
                this.tasks.filter(t => t.parentId === pid).forEach(t => {
                    res.push(t);
                    add(t.id);
                });
            };
            add(null);
            
            // Add any orphaned tasks (parentId references non-existent task)
            const knownIds = res.map(t => t.id);
            this.tasks.filter(t => !knownIds.includes(t.id)).forEach(t => {
                t.parentId = null;
                res.push(t);
            });
            
            return res;
        }

        getDepth(id, d = 0) {
            const t = this.tasks.find(x => x.id === id);
            return (t && t.parentId) ? this.getDepth(t.parentId, d + 1) : d;
        }

        // ===== INDENT/OUTDENT =====
        indent(id) {
            this.saveCheckpoint();
            const list = this.getFlatList();
            const idx = list.findIndex(t => t.id === id);
            if (idx <= 0) return;
            
            const task = list[idx];
            const prev = list[idx - 1];
            const taskDepth = this.getDepth(task.id);
            const prevDepth = this.getDepth(prev.id);
            
            if (prevDepth < taskDepth) return;
            
            let newParentId = null;
            if (prevDepth === taskDepth) {
                newParentId = prev.id;
            } else {
                let curr = prev;
                while (curr && this.getDepth(curr.id) > taskDepth) {
                    curr = this.tasks.find(t => t.id === curr.parentId);
                }
                if (curr) newParentId = curr.id;
            }
            
            this.tasks.find(t => t.id === id).parentId = newParentId;
            this.recalculateAll();
            this.saveData();
            this.render();
        }

        indentSelection() {
            this.saveCheckpoint();
            const list = this.getFlatList();
            const selectedIds = new Set(this.selectedTaskIds);
            const updates = new Map();
            
            const sortedSelection = list.filter(t => selectedIds.has(t.id));
            
            sortedSelection.forEach(task => {
                if (task.parentId && selectedIds.has(task.parentId)) return;
                
                const idx = list.findIndex(t => t.id === task.id);
                if (idx <= 0) return;
                
                const prev = list[idx - 1];
                const taskDepth = this.getDepth(task.id);
                const prevDepth = this.getDepth(prev.id);
                
                if (prevDepth < taskDepth) return;
                
                let newParentId = null;
                if (prevDepth === taskDepth) {
                    newParentId = prev.id;
                } else {
                    let curr = prev;
                    while (curr && this.getDepth(curr.id) > taskDepth) {
                        curr = this.tasks.find(t => t.id === curr.parentId);
                    }
                    if (curr) newParentId = curr.id;
                }
                
                updates.set(task.id, newParentId);
            });
            
            if (updates.size > 0) {
                updates.forEach((newPid, taskId) => {
                    this.tasks.find(t => t.id === taskId).parentId = newPid;
                });
                this.recalculateAll();
                this.saveData();
                this.render();
            }
        }

        outdent(id) {
            this.saveCheckpoint();
            const t = this.tasks.find(t => t.id === id);
            if (t && t.parentId) {
                const parent = this.tasks.find(p => p.id === t.parentId);
                t.parentId = parent ? parent.parentId : null;
                this.recalculateAll();
                this.saveData();
                this.render();
            }
        }

        outdentSelection() {
            this.saveCheckpoint();
            const list = this.getFlatList();
            const selectedIds = new Set(this.selectedTaskIds);
            const updates = new Map();
            
            const sortedSelection = list.filter(t => selectedIds.has(t.id));
            
            sortedSelection.forEach(task => {
                if (!task.parentId) return;
                if (!selectedIds.has(task.parentId)) {
                    const currentParent = this.tasks.find(p => p.id === task.parentId);
                    const newParentId = currentParent ? currentParent.parentId : null;
                    updates.set(task.id, newParentId);
                }
            });
            
            if (updates.size > 0) {
                updates.forEach((newPid, taskId) => {
                    this.tasks.find(t => t.id === taskId).parentId = newPid;
                });
                this.recalculateAll();
                this.saveData();
                this.render();
            }
        }

        // ===== PANE RESIZER =====
        makeResizable() {
            const resizer = document.getElementById('resizer');
            const leftSide = document.getElementById('gridPane');
            let x = 0;
            let leftWidth = 0;
            
            const onMouseDown = (e) => {
                x = e.clientX;
                leftWidth = leftSide.getBoundingClientRect().width;
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                resizer.classList.add('active');
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'col-resize';
            };
            
            const onMouseMove = (e) => {
                const newWidth = leftWidth + e.clientX - x;
                leftSide.style.width = `${Math.max(300, newWidth)}px`;
            };
            
            const onMouseUp = () => {
                resizer.classList.remove('active');
                document.body.style.userSelect = '';
                document.body.style.cursor = '';
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };
            
            resizer.addEventListener('mousedown', onMouseDown);
        }

        startColResize(e, varName) {
            e.preventDefault();
            e.stopPropagation();
            
            const gridPane = document.getElementById('gridPane');
            const startX = e.clientX;
            const startWidth = parseInt(getComputedStyle(gridPane).getPropertyValue(varName));
            
            e.target.classList.add('active');
            document.body.style.cursor = 'col-resize';
            
            const onMouseMove = (moveEvent) => {
                const diff = moveEvent.clientX - startX;
                const newWidth = Math.max(30, startWidth + diff);
                gridPane.style.setProperty(varName, newWidth + 'px');
            };
            
            const onMouseUp = () => {
                e.target.classList.remove('active');
                document.body.style.cursor = '';
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        // ===== TASK OPERATIONS =====
        addTask() {
            this.saveCheckpoint();
            const id = Date.now().toString();
            const today = new Date().toISOString().split('T')[0];
            
            this.tasks.push({
                id,
                name: "New Task",
                start: today,
                end: today,
                duration: 1,
                parentId: null,
                dependencies: [],
                progress: 0,
                _collapsed: false
            });
            
            this.recalculateAll();
            this.saveData();
            this.render();
            
            // Select and scroll to new task
            this.selectedTaskIds.clear();
            this.selectedTaskIds.add(id);
            this.lastFocusedTaskId = id;
            this.scrollToRow(id);
        }

        deleteTask(id) {
            const isParent = this.isParent(id);
            const taskName = this.tasks.find(t => t.id === id)?.name || 'this task';
            
            const message = isParent 
                ? `Delete "${taskName}" and all its children?`
                : `Delete "${taskName}"?`;
            
            if (!confirm(message)) return;
            
            this.saveCheckpoint();
            
            let idsToRemove = [id];
            
            if (isParent) {
                const getDescendants = (pid) => {
                    this.tasks.filter(c => c.parentId === pid).forEach(c => {
                        idsToRemove.push(c.id);
                        getDescendants(c.id);
                    });
                };
                getDescendants(id);
            }
            
            // Remove tasks
            this.tasks = this.tasks.filter(t => !idsToRemove.includes(t.id));
            
            // Clean up dependencies referencing deleted tasks
            this.tasks.forEach(t => {
                t.dependencies = t.dependencies.filter(d => !idsToRemove.includes(d.id));
            });
            
            // Clean up selection
            idsToRemove.forEach(remId => this.selectedTaskIds.delete(remId));
            
            this.recalculateAll();
            this.saveData();
            this.render();
            this.showToast(`Deleted ${idsToRemove.length} task(s)`, 'info');
        }

        deleteSelectedTasks() {
            const count = this.selectedTaskIds.size;
            if (count === 0) return;
            
            if (!confirm(`Delete ${count} selected task(s)?`)) return;
            
            this.saveCheckpoint();
            const ids = Array.from(this.selectedTaskIds);
            
            ids.forEach(id => {
                let idsToRemove = [id];
                
                if (this.isParent(id)) {
                    const getDescendants = (pid) => {
                        this.tasks.filter(c => c.parentId === pid).forEach(c => {
                            idsToRemove.push(c.id);
                            getDescendants(c.id);
                        });
                    };
                    getDescendants(id);
                }
                
                this.tasks = this.tasks.filter(t => !idsToRemove.includes(t.id));
                this.tasks.forEach(t => {
                    t.dependencies = t.dependencies.filter(d => !idsToRemove.includes(d.id));
                });
            });
            
            this.selectedTaskIds.clear();
            this.recalculateAll();
            this.saveData();
            this.render();
            this.showToast(`Deleted ${count} task(s)`, 'info');
        }

        // ===== GANTT DRAG HANDLING =====
        handleDrag(task, start, end) {
            this.saveCheckpoint();
            const t = this.tasks.find(x => x.id === task.id);
            
            if (!t || this.isParent(t.id)) {
                this.render();
                return;
            }
            
            const startStr = start.toISOString().split('T')[0];
            const endStr = end.toISOString().split('T')[0];
            
            t.start = startStr;
            t.duration = this.calcDurationWorkDays(startStr, endStr);
            t.constraintType = 'snet';
            t.constraintDate = startStr;
            
            this.recalculateAll();
            this.saveData();
            this.renderGrid();
            lucide.createIcons();
        }

        // ===== RENDER =====
        render() {
            this.renderGrid();
            this.renderGantt();
            lucide.createIcons();
        }

        renderGantt() {
            const validTasks = this.tasks.filter(t => t.start && t.end && this.isVisible(t.id));
            
            const ganttData = validTasks.map(t => ({
                id: t.id,
                name: t.name,
                start: t.start,
                end: t.end,
                progress: t.progress || 0,
                dependencies: (t.dependencies || []).map(d => d.id).join(", "),
                custom_class: (this.isParent(t.id) ? 'parent' : '') + (t._isCritical ? ' critical' : '')
            }));
            
            const chartEl = document.getElementById('gantt-chart');
            
            if (ganttData.length === 0) {
                chartEl.innerHTML = '<div class="text-gray-400 text-xs p-4">No visible tasks with dates</div>';
                this.gantt = null;
                return;
            }
            
            if (!this.gantt) {
                this.gantt = new Gantt("#gantt-chart", ganttData, {
                    header_height: 50,
                    column_width: 30,
                    step: 24,
                    view_modes: ProScheduler.VIEW_OPTIONS,
                    bar_height: 20,
                    bar_corner_radius: 3,
                    arrow_curve: 5,
                    padding: 18,
                    view_mode: this.viewMode,
                    date_format: 'YYYY-MM-DD',
                    on_date_change: (task, start, end) => this.handleDrag(task, start, end)
                });
            } else {
                this.gantt.refresh(ganttData);
            }
        }

        // ===== LINKS MODAL =====
        openLinks(id) {
            this.activeTaskId = id;
            const task = this.tasks.find(t => t.id === id);
            this.tempDependencies = JSON.parse(JSON.stringify(task.dependencies || []));
            this.renderModal();
            document.getElementById('linkModal').showModal();
        }

        switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tab-${tab}`).classList.add('active');
            document.getElementById('view-pred').classList.add('hidden');
            document.getElementById('view-succ').classList.add('hidden');
            document.getElementById(`view-${tab}`).classList.remove('hidden');
        }

        renderModal() {
            const predBody = document.getElementById('pred-list-body');
            predBody.innerHTML = '';
            
            this.tempDependencies.forEach((dep, idx) => {
                const t = this.tasks.find(x => x.id === dep.id);
                if (!t) return;
                
                predBody.innerHTML += `
                    <tr class="border-b border-gray-100 hover:bg-slate-50">
                        <td class="p-2">${this.escapeHtml(t.name)}</td>
                        <td class="p-2">
                            <select onchange="app.updateTempLink(${idx}, 'type', this.value)" class="border rounded p-1 text-xs w-full bg-white">
                                <option value="FS" ${dep.type === 'FS' ? 'selected' : ''}>Finish to Start</option>
                                <option value="SS" ${dep.type === 'SS' ? 'selected' : ''}>Start to Start</option>
                                <option value="FF" ${dep.type === 'FF' ? 'selected' : ''}>Finish to Finish</option>
                            </select>
                        </td>
                        <td class="p-2">
                            <input type="number" value="${dep.lag || 0}" onchange="app.updateTempLink(${idx}, 'lag', this.value)" class="border rounded p-1 w-16 text-xs text-center">
                        </td>
                        <td class="p-2 text-center">
                            <button onclick="app.removeTempLink(${idx})" class="text-red-400 hover:text-red-600">
                                <i data-lucide="trash-2" class="w-3 h-3"></i>
                            </button>
                        </td>
                    </tr>`;
            });
            
            if (this.tempDependencies.length === 0) {
                predBody.innerHTML = `<tr><td colspan="4" class="p-4 text-center text-gray-400 italic">No predecessors. Add one above.</td></tr>`;
            }
            
            // Populate dropdown
            const select = document.getElementById('new-pred-select');
            select.innerHTML = '<option value="">Select task...</option>';
            
            const existingIds = this.tempDependencies.map(d => d.id);
            this.tasks
                .filter(t => t.id !== this.activeTaskId && !existingIds.includes(t.id) && !this.isParent(t.id))
                .forEach(t => {
                    select.innerHTML += `<option value="${t.id}">${this.escapeHtml(t.name)}</option>`;
                });
            
            // Successors tab
            const succBody = document.getElementById('succ-list-body');
            succBody.innerHTML = '';
            
            const successors = this.tasks.filter(t => 
                t.dependencies && t.dependencies.some(d => d.id === this.activeTaskId)
            );
            
            if (successors.length === 0) {
                succBody.innerHTML = `<tr><td colspan="3" class="p-4 text-center text-gray-400 italic">No successors found.</td></tr>`;
            } else {
                successors.forEach(succ => {
                    const link = succ.dependencies.find(d => d.id === this.activeTaskId);
                    const typeLabels = { 'FS': 'Finish to Start', 'SS': 'Start to Start', 'FF': 'Finish to Finish' };
                    succBody.innerHTML += `
                        <tr class="border-b border-gray-100">
                            <td class="p-2 font-medium">${this.escapeHtml(succ.name)}</td>
                            <td class="p-2 text-gray-600">${typeLabels[link.type] || link.type}</td>
                            <td class="p-2 text-gray-600">${link.lag || 0} days</td>
                        </tr>`;
                });
            }
            
            lucide.createIcons();
        }

        addPredecessor() {
            const select = document.getElementById('new-pred-select');
            const id = select.value;
            if (!id) return;
            
            this.tempDependencies.push({ id: id, type: 'FS', lag: 0 });
            this.renderModal();
        }

        removeTempLink(index) {
            this.tempDependencies.splice(index, 1);
            this.renderModal();
        }

        updateTempLink(index, field, value) {
            if (field === 'lag') value = parseInt(value) || 0;
            this.tempDependencies[index][field] = value;
        }

        saveLinks() {
            this.saveCheckpoint();
            const task = this.tasks.find(t => t.id === this.activeTaskId);
            task.dependencies = JSON.parse(JSON.stringify(this.tempDependencies));
            document.getElementById('linkModal').close();
            this.recalculateAll();
            this.saveData();
            this.render();
            this.showToast('Dependencies updated', 'success');
        }
    }

    // Initialize the application
    const app = new ProScheduler();
</script>
</body>
</html>