<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Logic Scheduler | V8.6 (Typing Fix)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/frappe-gantt/0.6.1/frappe-gantt.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/frappe-gantt/0.6.1/frappe-gantt.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        
        /* LAYOUT */
        .split-container { display: flex; height: calc(100vh - 56px); width: 100%; overflow: hidden; position: relative; }
        
        /* GRID PANE & COLUMNS */
        .grid-pane { 
            width: 45%; 
            min-width: 400px; 
            display: flex; 
            flex-direction: column; 
            background: white; 
            border-right: none;
            /* Default Widths */
            --w-chk: 30px; 
            --w-id: 30px;
            --w-name: 220px;
            --w-dur: 50px;
            --w-start: 110px; 
            --w-end: 95px;
            --w-actions: 140px;
        }

        .resizer { width: 6px; cursor: col-resize; background: #f1f5f9; border-left: 1px solid #e2e8f0; border-right: 1px solid #e2e8f0; flex: 0 0 auto; z-index: 50; display: flex; align-items: center; justify-content: center; transition: background 0.2s; }
        .resizer:hover, .resizer.active { background: #cbd5e1; }
        .gantt-pane { flex: 1; min-width: 200px; overflow: auto; background: #f8fafc; position: relative; }

        /* GRID STYLES */
        .grid-header { 
            position: sticky; top: 0; background: #f8fafc; font-size: 11px; font-weight: 700; color: #64748b; text-transform: uppercase; z-index: 10; border-bottom: 1px solid #cbd5e1; height: 50px; display: flex; align-items: center; 
            min-width: fit-content; 
        }
        .grid-body { overflow-y: auto; flex: 1; overflow-x: auto; }
        
        .grid-row { display: flex; border-bottom: 1px solid #f1f5f9; height: 38px; align-items: center; font-size: 13px; background: white; min-width: fit-content; }
        .grid-row:hover { background-color: #f8fafc; }
        
        /* SELECTION MODE STYLES */
        .grid-row.row-selected {
            background-color: #f5f3ff !important; /* Light Indigo */
            box-shadow: inset 3px 0 0 0 #6366f1;   /* Indigo Marker */
        }
        .grid-row.row-selected .cell-input { background: transparent; }
        .select-checkbox {
            width: 14px; height: 14px; border-radius: 4px; cursor: pointer; accent-color: #6366f1;
        }

        /* COLUMNS */
        .col-cell {
            flex-shrink: 0;
            border-right: 1px solid #e2e8f0;
            height: 100%;
            display: flex;
            align-items: center;
            position: relative;
        }
        .col-resizer {
            width: 5px; cursor: col-resize; position: absolute; right: -2px; top: 0; bottom: 0; z-index: 20; background: transparent; transition: background 0.2s;
        }
        .col-resizer:hover, .col-resizer.active { background: #6366f1; }

        /* INPUTS & DRAG */
        .grid-row.sortable-ghost { background: #e0e7ff; opacity: 0.4; }
        .grid-row.sortable-drag { background: #fff; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); cursor: grabbing; opacity: 1 !important; }
        
        .cell-input { width: 100%; height: 100%; background: transparent; border: none; outline: none; padding: 0 8px; color: #334155; }
        .cell-input:focus { background: white; box-shadow: inset 0 0 0 2px #6366f1; }
        .cell-readonly { background: #f1f5f9; color: #94a3b8; font-style: italic; pointer-events: none; }
        .drag-handle { cursor: grab; color: #94a3b8; }
        .drag-handle:active { cursor: grabbing; }

        /* SIDE DRAWER */
        .side-drawer {
            position: absolute; top: 0; right: -400px; width: 400px; height: 100%;
            background: white; border-left: 1px solid #cbd5e1; shadow: -5px 0 15px rgba(0,0,0,0.05);
            z-index: 100; transition: right 0.3s ease-in-out; display: flex; flex-direction: column;
        }
        .side-drawer.open { right: 0; box-shadow: -10px 0 25px -5px rgba(0, 0, 0, 0.1); }
        .drawer-header { padding: 16px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center; background: #f8fafc; }
        .drawer-body { padding: 20px; overflow-y: auto; flex: 1; }
        .form-group { margin-bottom: 16px; }
        .form-label { display: block; font-size: 11px; font-weight: 700; color: #64748b; margin-bottom: 4px; text-transform: uppercase; }
        .form-input { width: 100%; border: 1px solid #cbd5e1; rounded: 4px; padding: 8px; font-size: 13px; outline: none; transition: border-color 0.2s; }
        .form-input:focus { border-color: #6366f1; ring: 2px solid #e0e7ff; }

        /* GANTT OVERRIDES */
        .bar-wrapper.parent .bar { fill: #334155; height: 10px !important; transform: translateY(6px); opacity: 0.8; }
        .bar-wrapper .bar { fill: #93c5fd; rx: 2; ry: 2; }
        .bar-wrapper.critical .bar { fill: #f87171 !important; stroke: #dc2626; stroke-width: 1px; }
        .gantt-pane::-webkit-scrollbar { width: 8px; height: 8px; }
        .gantt-pane::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .gantt-pane::-webkit-scrollbar-corner { background: transparent; }
        .tab-btn { padding: 8px 16px; border-bottom: 2px solid transparent; color: #64748b; font-size: 13px; font-weight: 500; }
        .tab-btn.active { border-bottom-color: #0f172a; color: #0f172a; }
    </style>
</head>
<body class="bg-white text-slate-800 h-screen flex flex-col overflow-hidden">

    <header class="h-14 bg-white border-b border-gray-200 flex items-center justify-between px-4 flex-none z-20 shadow-sm">
        <div class="flex items-center gap-3">
            <div class="bg-purple-600 text-white p-1.5 rounded">
                <i data-lucide="maximize" class="w-5 h-5"></i>
            </div>
            <div>
                <h1 class="font-bold text-lg text-slate-800 leading-none">Pro Logic <span class="text-xs font-normal text-gray-400 ml-1">v8.6</span></h1>
                <p class="text-[10px] text-gray-500 font-medium">Double-Click Row for Details | Type Date to Pin ðŸ“Œ</p>
            </div>
        </div>

        <div class="flex items-center gap-2">
             <div class="flex items-center bg-gray-100 rounded p-1 gap-1">
                <button onclick="app.undo()" class="p-1 hover:bg-white rounded text-gray-600" title="Undo (Ctrl+Z)"><i data-lucide="undo-2" class="w-3 h-3"></i></button>
                <button onclick="app.redo()" class="p-1 hover:bg-white rounded text-gray-600" title="Redo (Ctrl+Y)"><i data-lucide="redo-2" class="w-3 h-3"></i></button>
                <div class="w-px h-3 bg-gray-300 mx-1"></div>
                <button onclick="app.downloadJSON()" class="text-xs font-bold px-2 py-1 hover:bg-white rounded text-gray-600 flex items-center gap-1" title="Save Backup"><i data-lucide="save" class="w-3 h-3"></i> Save</button>
                <button onclick="document.getElementById('file-upload').click()" class="text-xs font-bold px-2 py-1 hover:bg-white rounded text-gray-600 flex items-center gap-1" title="Load JSON or XML"><i data-lucide="upload" class="w-3 h-3"></i> Load</button>
                <div class="w-px h-3 bg-gray-300 mx-1"></div>
                <button onclick="app.exportToMSP()" class="text-xs font-bold px-2 py-1 hover:bg-white rounded text-emerald-700 flex items-center gap-1" title="Export to MS Project"><i data-lucide="file-spreadsheet" class="w-3 h-3"></i> XML</button>
            </div>
            <input type="file" id="file-upload" class="hidden" accept=".json,.xml" onchange="app.uploadFile(this)">

            <div class="h-6 w-px bg-gray-300 mx-2"></div>
            
            <button onclick="app.addTask()" class="flex items-center gap-2 bg-slate-800 hover:bg-slate-900 text-white px-3 py-1.5 rounded text-sm font-medium transition" title="Add to bottom">
                <i data-lucide="plus" class="w-4 h-4"></i> Add
            </button>
            
            <div class="h-6 w-px bg-gray-300 mx-2"></div>
            
            <div class="flex items-center bg-gray-100 rounded p-1">
                <button onclick="app.zoom('out')" class="p-1 hover:bg-white rounded text-gray-600" title="Zoom Out"><i data-lucide="minus" class="w-3 h-3"></i></button>
                <span id="zoom-label" class="text-[10px] font-bold px-2 text-gray-500 w-12 text-center">Week</span>
                <button onclick="app.zoom('in')" class="p-1 hover:bg-white rounded text-gray-600" title="Zoom In"><i data-lucide="plus" class="w-3 h-3"></i></button>
            </div>

            <button onclick="app.openPopout()" class="text-xs font-bold px-3 py-1.5 rounded bg-indigo-50 text-indigo-700 hover:bg-indigo-100 flex items-center gap-1 ml-2">
                <i data-lucide="external-link" class="w-3 h-3"></i> Popout
            </button>
        </div>
    </header>

    <div class="split-container" id="splitContainer">
        <div class="grid-pane" id="gridPane">
            <div class="grid-header">
                <div class="col-cell justify-center" style="width: var(--w-chk)">
                    <i data-lucide="check-square" class="w-3 h-3"></i>
                    <div class="col-resizer" onmousedown="app.startColResize(event, '--w-chk')"></div>
                </div>
                <div class="col-cell justify-center" style="width: var(--w-id)">
                    # <div class="col-resizer" onmousedown="app.startColResize(event, '--w-id')"></div>
                </div>
                <div class="col-cell px-2" style="width: var(--w-name)">
                    Task Name <div class="col-resizer" onmousedown="app.startColResize(event, '--w-name')"></div>
                </div>
                <div class="col-cell justify-center" style="width: var(--w-dur)">
                    Dur <div class="col-resizer" onmousedown="app.startColResize(event, '--w-dur')"></div>
                </div>
                <div class="col-cell px-2" style="width: var(--w-start)">
                    Start <div class="col-resizer" onmousedown="app.startColResize(event, '--w-start')"></div>
                </div>
                <div class="col-cell px-2" style="width: var(--w-end)">
                    Finish <div class="col-resizer" onmousedown="app.startColResize(event, '--w-end')"></div>
                </div>
                <div class="col-cell justify-center" style="width: var(--w-actions)">
                    Actions
                </div>
            </div>
            
            <div id="grid-body" class="grid-body"></div>
        </div>
        <div class="resizer" id="resizer"></div>
        <div class="gantt-pane" id="ganttPane">
            <div id="gantt-chart" class="h-full"></div>
        </div>

        <div id="sideDrawer" class="side-drawer shadow-2xl">
            <div class="drawer-header">
                <h3 class="font-bold text-slate-800">Task Details</h3>
                <button onclick="app.closeDrawer()" class="text-gray-400 hover:text-gray-600"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
            <div class="drawer-body">
                <div class="form-group">
                    <label class="form-label">Task Name</label>
                    <input type="text" id="drawer-name" class="form-input" onchange="app.updateFromDrawer('name', this.value)">
                </div>
                <div class="form-group grid grid-cols-2 gap-2">
                    <div>
                        <label class="form-label">Duration (Days)</label>
                        <input type="number" id="drawer-duration" class="form-input" onchange="app.updateFromDrawer('duration', this.value)">
                    </div>
                    <div>
                         <label class="form-label">% Complete</label>
                         <input type="number" id="drawer-progress" class="form-input" onchange="app.updateFromDrawer('progress', this.value)">
                    </div>
                </div>

                <div class="my-4 border-t border-gray-100 pt-4">
                    <h4 class="font-bold text-xs text-slate-800 mb-3 uppercase tracking-wider">Constraints & Logic</h4>
                    
                    <div class="form-group">
                        <label class="form-label">Constraint Type</label>
                        <select id="drawer-constraintType" class="form-input bg-gray-50" onchange="app.updateFromDrawer('constraintType', this.value)">
                            <option value="asap">As Soon As Possible (Default)</option>
                            <option value="snet">Start No Earlier Than (SNET)</option>
                            <option value="mfo">Must Finish On (Hard Deadline)</option>
                        </select>
                        <p class="text-[10px] text-gray-500 mt-1" id="constraint-desc">Tasks flow naturally based on dependencies.</p>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Constraint Date</label>
                        <input type="date" id="drawer-constraintDate" class="form-input" onchange="app.updateFromDrawer('constraintDate', this.value)">
                    </div>
                </div>
            </div>
            <div class="p-4 bg-gray-50 border-t border-gray-200">
                <button onclick="app.deleteTask(app.activeTaskId); app.closeDrawer();" class="w-full text-red-600 bg-white border border-gray-300 hover:bg-red-50 font-medium text-xs py-2 rounded">Delete Task</button>
            </div>
        </div>
    </div>

    <dialog id="linkModal" class="rounded-lg shadow-2xl border border-gray-200 w-[500px] backdrop:bg-black/20 p-0 overflow-hidden">
        <div class="bg-gray-50 border-b border-gray-200 px-4 py-2 flex items-center justify-between">
            <h3 class="font-bold text-sm">Task Links</h3>
            <button onclick="document.getElementById('linkModal').close()" class="text-gray-400 hover:text-gray-600"><i data-lucide="x" class="w-4 h-4"></i></button>
        </div>
        <div class="flex border-b border-gray-200 bg-white">
            <button onclick="app.switchTab('pred')" id="tab-pred" class="tab-btn active w-1/2">Predecessors (Incoming)</button>
            <button onclick="app.switchTab('succ')" id="tab-succ" class="tab-btn w-1/2">Successors (Outgoing)</button>
        </div>
        <div class="p-4 bg-white h-[300px] overflow-y-auto">
            <div id="view-pred">
                <div class="flex gap-2 mb-3">
                    <select id="new-pred-select" class="flex-1 text-xs border border-gray-300 rounded p-1.5 focus:border-indigo-500 outline-none bg-white"></select>
                    <button onclick="app.addPredecessor()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded text-xs font-bold">Add Link</button>
                </div>
                <table class="w-full text-xs text-left">
                    <thead class="bg-gray-50 text-gray-500 border-b">
                        <tr><th class="p-2 font-medium">Task Name</th><th class="p-2 font-medium">Type</th><th class="p-2 font-medium w-16">Lag</th><th class="p-2 w-8"></th></tr>
                    </thead>
                    <tbody id="pred-list-body"></tbody>
                </table>
            </div>
            <div id="view-succ" class="hidden">
                <p class="text-xs text-gray-500 mb-2">Tasks waiting on this task:</p>
                <table class="w-full text-xs text-left">
                    <thead class="bg-gray-50 text-gray-500 border-b"><tr><th class="p-2 font-medium">Task Name</th><th class="p-2 font-medium">Relationship</th><th class="p-2 font-medium">Lag</th></tr></thead>
                    <tbody id="succ-list-body"></tbody>
                </table>
            </div>
        </div>
        <div class="bg-gray-50 p-3 flex justify-end gap-2 border-t border-gray-200">
            <button onclick="document.getElementById('linkModal').close()" class="px-3 py-1.5 text-xs font-medium bg-white border border-gray-300 rounded hover:bg-gray-50">Cancel</button>
            <button onclick="app.saveLinks()" class="px-3 py-1.5 text-xs font-medium bg-slate-800 text-white rounded hover:bg-slate-700">Save Logic</button>
        </div>
    </dialog>

<script>
    class ProScheduler {
        constructor() {
            this.tasks = [];
            this.history = []; 
            this.future = [];  
            this.clipboard = null;
            this.gantt = null;
            this.selectedTaskIds = new Set(); 
            this.lastFocusedTaskId = null;    
            this.anchorTaskId = null;         
            this.activeTaskId = null;         
            this.viewMode = 'Week';
            this.viewOptions = ['Day', 'Week', 'Month'];
            this.tempDependencies = [];
            this.init();
        }

        init() {
            this.loadData();
            this.recalculateAll(); 
            this.render();
            this.makeResizable();
            this.initScrollSync();
            this.initSortable(); 
            this.initKeyboardShortcuts();
            lucide.createIcons();
        }

        // --- DRAWER & CONSTRAINTS ---
        openDrawer(id) {
            if (this.activeTaskId === id && document.getElementById('sideDrawer').classList.contains('open')) {
                this.closeDrawer();
                return;
            }
            this.activeTaskId = id;
            const task = this.tasks.find(t => t.id === id);
            if (!task) return;
            document.getElementById('drawer-name').value = task.name;
            document.getElementById('drawer-duration').value = task.duration;
            document.getElementById('drawer-progress').value = task.progress || 0;
            document.getElementById('drawer-constraintType').value = task.constraintType || 'asap';
            document.getElementById('drawer-constraintDate').value = task.constraintDate || '';
            this.updateConstraintDesc(task.constraintType || 'asap');
            document.getElementById('sideDrawer').classList.add('open');
        }

        closeDrawer() {
            document.getElementById('sideDrawer').classList.remove('open');
            this.activeTaskId = null;
        }

        updateFromDrawer(field, value) {
            if (!this.activeTaskId) return;
            if (field === 'constraintType') { this.updateConstraintDesc(value); }
            this.update(this.activeTaskId, field, value);
        }

        updateConstraintDesc(type) {
            const el = document.getElementById('constraint-desc');
            if (type === 'asap') el.innerText = "Task flows naturally based on predecessors.";
            if (type === 'snet') el.innerText = "Task cannot start earlier than date, but can start later.";
            if (type === 'mfo') el.innerText = "Task MUST finish on this date. Overrides logic.";
        }

        // --- CORE LOGIC ---
        recalculateAll() {
             let changed = true; let loops = 0;
            while (changed && loops < 50) {
                changed = false; loops++;
                this.tasks.forEach(t => {
                    let dependencyStart = null;
                    if (t.dependencies.length > 0) {
                        let maxStart = [];
                        t.dependencies.forEach(dep => {
                            const pred = this.tasks.find(x => x.id === dep.id);
                            if (pred && pred.start && pred.end) {
                                if (dep.type === 'FS') maxStart.push(this.addWorkDays(this.addWorkDays(pred.end, 1), dep.lag || 0));
                                if (dep.type === 'SS') maxStart.push(this.addWorkDays(pred.start, dep.lag || 0));
                                if (dep.type === 'FF') maxStart.push(this.addWorkDays(this.addWorkDays(pred.end, dep.lag || 0), -t.duration));
                            }
                        });
                        if (maxStart.length > 0) {
                            maxStart.sort().reverse(); 
                            dependencyStart = maxStart[0];
                        }
                    }

                    const type = t.constraintType || 'asap';
                    const cDate = t.constraintDate;
                    
                    if (this.isParent(t.id)) {
                        t._minStartConstraint = dependencyStart; 
                    } else {
                        let finalStart = dependencyStart;
                        if (type === 'snet' && cDate) {
                            if (!finalStart || cDate > finalStart) finalStart = cDate;
                        } 
                        else if (type === 'mfo' && cDate) {
                            t.end = cDate;
                            t.start = this.addWorkDays(cDate, -(t.duration)); 
                        }
                        else if (type === 'asap') {
                            if (!finalStart && !t.start) finalStart = new Date().toISOString().split('T')[0];
                        }
                        if (type !== 'mfo') {
                            if (!finalStart) finalStart = t.start; 
                            if (t.start !== finalStart) { t.start = finalStart; changed = true; }
                        }
                        if (type !== 'mfo' && t.start && t.duration >= 0) {
                            const newEnd = this.addWorkDays(t.start, t.duration);
                            if (t.end !== newEnd) { t.end = newEnd; changed = true; }
                        }
                    }
                });

                this.tasks.forEach(p => {
                    if (!this.isParent(p.id)) return;
                    const children = this.tasks.filter(c => c.parentId === p.id && c.start && c.end);
                    if (children.length > 0) {
                        let minStart = children.map(c => c.start).sort()[0];
                        const maxEnd = children.map(c => c.end).sort().reverse()[0];
                        if (p.start !== minStart || p.end !== maxEnd) { 
                            p.start = minStart; p.end = maxEnd; 
                            p.duration = this.calcDurationWorkDays(minStart, maxEnd); 
                            changed = true; 
                        }
                    }
                });
            }
            this.calcCriticalPath();
        }

        update(id, field, value) {
            this.saveCheckpoint(); 
            const task = this.tasks.find(t => t.id === id);
            
            if (field === 'duration') task.duration = parseInt(value) || 0;
            if (field === 'name') task.name = value;
            if (field === 'progress') task.progress = parseInt(value) || 0;
            if (field === 'start') {
                task.constraintType = 'snet';
                task.constraintDate = value;
            }
            if (field === 'constraintType') task.constraintType = value;
            if (field === 'constraintDate') task.constraintDate = value;

            this.recalculateAll(); 
            this.saveData(); 
            
            // FIX: Don't re-render entire grid if focus is inside an input
            // We only re-render if the drawer is updating, or if we need to show the pin/move rows
            // But we must check if active element is an input
            const activeEl = document.activeElement;
            const isTyping = activeEl && activeEl.classList.contains('cell-input');
            
            if (!isTyping) {
                this.render();
            } else {
                // If typing, only update Gantt, delay grid render? 
                // Actually, if we update dependencies, other rows might move.
                // But for the current row, we shouldn't kill the input.
                // The safest bet is relying on 'onblur' now, so 'update' won't even be called while typing.
                // But if it is called from Drawer, we render.
                this.render();
            }
            
            if(this.activeTaskId === id && document.getElementById('sideDrawer').classList.contains('open')) {
                // Drawer sync logic if needed
            }
        }

        // --- RENDER GRID (UPDATED TO USE ONBLUR) ---
        renderGrid() {
            const container = document.getElementById('grid-body');
            container.innerHTML = '';
            const sorted = this.getFlatList();

            sorted.forEach((task, index) => {
                if (!this.isVisible(task.id)) return; 
                const depth = this.getDepth(task.id);
                const isParent = this.isParent(task.id);
                const padding = depth * 20;
                const isSelected = this.selectedTaskIds.has(task.id); 

                let pinIcon = '';
                if (task.constraintType === 'snet' || task.constraintType === 'mfo') {
                    const color = task.constraintType === 'mfo' ? 'text-red-500' : 'text-gray-400';
                    pinIcon = `<i data-lucide="pin" class="w-3 h-3 ${color} ml-1 absolute right-2 top-1/2 -translate-y-1/2"></i>`;
                }

                let collapseBtn = `<span class="w-5 inline-block"></span>`;
                if (isParent) {
                    const icon = task._collapsed ? 'chevron-right' : 'chevron-down';
                    collapseBtn = `<button onclick="app.toggleCollapse('${task.id}')" class="w-5 h-5 flex items-center justify-center hover:bg-gray-100 rounded text-gray-500 mr-1"><i data-lucide="${icon}" class="w-3 h-3"></i></button>`;
                }

                let actions = `<div class="flex items-center justify-center gap-1">`;
                actions += `<button onclick="app.outdent('${task.id}')" class="p-1 text-gray-400 hover:text-slate-800 rounded hover:bg-slate-100"><i data-lucide="outdent" class="w-3 h-3"></i></button>`;
                actions += `<button onclick="app.indent('${task.id}')" class="p-1 text-gray-400 hover:text-slate-800 rounded hover:bg-slate-100"><i data-lucide="indent" class="w-3 h-3"></i></button>`;
                if (!isParent) actions += `<button onclick="app.openLinks('${task.id}')" class="p-1 text-gray-400 hover:text-indigo-600 rounded hover:bg-indigo-50 ml-1"><i data-lucide="link" class="w-3 h-3"></i></button>`;
                actions += `<button onclick="app.deleteTask('${task.id}')" class="p-1 text-gray-400 hover:text-red-600 rounded hover:bg-red-50 ml-1"><i data-lucide="trash-2" class="w-3 h-3"></i></button>`;
                actions += `</div>`;

                // Changed onchange to onblur for inputs to prevent premature updates while typing
                container.innerHTML += `
                    <div class="grid-row group ${isParent ? 'bg-slate-50' : ''} ${isSelected ? 'row-selected' : ''}" 
                         data-id="${task.id}"
                         onclick="app.handleRowClick(event, '${task.id}')"
                         ondblclick="app.openDrawer('${task.id}')"
                    >
                        <div class="col-cell justify-center" style="width: var(--w-chk)">
                            <input type="checkbox" class="select-checkbox" ${isSelected ? 'checked' : ''} style="pointer-events:none;">
                            <div class="col-resizer" onmousedown="app.startColResize(event, '--w-chk')"></div>
                        </div>
                        <div class="col-cell justify-center text-gray-400 text-[10px] drag-handle transition-colors h-full" style="width: var(--w-id)">
                            ${index + 1}
                            <div class="col-resizer" onmousedown="app.startColResize(event, '--w-id')"></div>
                        </div>
                        <div class="col-cell px-2 relative overflow-hidden" style="width: var(--w-name)">
                            <div style="width: ${padding}px" class="flex-none border-r border-dashed border-gray-300 h-full mr-2"></div>
                            ${collapseBtn}
                            <input value="${task.name}" 
                                onblur="app.update('${task.id}', 'name', this.value)" 
                                onkeydown="if(event.key === 'Enter') this.blur()"
                                class="cell-input font-medium ${isParent ? 'font-bold' : ''}" 
                            >
                            <div class="col-resizer" onmousedown="app.startColResize(event, '--w-name')"></div>
                        </div>
                        <div class="col-cell" style="width: var(--w-dur)">
                            <input type="number" value="${task.duration}" onblur="app.update('${task.id}', 'duration', this.value)" onkeydown="if(event.key === 'Enter') this.blur()" class="cell-input text-center ${isParent ? 'cell-readonly' : ''}" ${isParent ? 'readonly' : ''}>
                            <div class="col-resizer" onmousedown="app.startColResize(event, '--w-dur')"></div>
                        </div>
                        <div class="col-cell relative" style="width: var(--w-start)">
                            <input type="date" value="${task.start}" onblur="app.update('${task.id}', 'start', this.value)" onkeydown="if(event.key === 'Enter') this.blur()" class="cell-input text-xs ${isParent ? 'cell-readonly' : ''}" ${isParent ? 'readonly' : ''}>
                            ${pinIcon}
                            <div class="col-resizer" onmousedown="app.startColResize(event, '--w-start')"></div>
                        </div>
                        <div class="col-cell" style="width: var(--w-end)">
                            <input type="date" value="${task.end}" readonly class="cell-input text-xs cell-readonly">
                            <div class="col-resizer" onmousedown="app.startColResize(event, '--w-end')"></div>
                        </div>
                        <div class="col-cell justify-center" style="width: var(--w-actions)">${actions}</div>
                    </div>
                `;
            });
        }

        // --- (EXISTING METHODS) ---
        saveCheckpoint() { const snapshot = JSON.stringify(this.tasks); if (this.history.length > 0 && this.history[this.history.length - 1] === snapshot) return; this.history.push(snapshot); this.future = []; }
        undo() { if (this.history.length === 0) return; this.future.push(JSON.stringify(this.tasks)); const previousState = this.history.pop(); this.tasks = JSON.parse(previousState); this.recalculateAll(); this.saveData(); this.render(); }
        redo() { if (this.future.length === 0) return; this.history.push(JSON.stringify(this.tasks)); const nextState = this.future.pop(); this.tasks = JSON.parse(nextState); this.recalculateAll(); this.saveData(); this.render(); }
        copySelection() { const selected = this.tasks.filter(t => this.selectedTaskIds.has(t.id)); if (selected.length === 0) return; const payload = new Set(); const getDescendants = (parentId) => { this.tasks.filter(t => t.parentId === parentId).forEach(child => { payload.add(child); getDescendants(child.id); }); }; selected.forEach(task => { payload.add(task); if (this.isParent(task.id)) { getDescendants(task.id); } }); this.clipboard = Array.from(payload).sort((a, b) => this.tasks.indexOf(a) - this.tasks.indexOf(b)); this.clipboard = JSON.parse(JSON.stringify(this.clipboard)); }
        pasteTasks() { if (!this.clipboard || this.clipboard.length === 0) return; this.saveCheckpoint(); const targetId = this.lastFocusedTaskId; let targetIndex = targetId ? this.tasks.findIndex(t => t.id === targetId) : this.tasks.length - 1; if (targetIndex === -1) targetIndex = this.tasks.length - 1; const targetTask = this.tasks[targetIndex]; const targetParentId = targetTask ? targetTask.parentId : null; const idMap = new Map(); const newTasks = []; this.clipboard.forEach(task => { const newId = Date.now() + Math.random().toString().slice(2,8); idMap.set(task.id, newId); const newTask = JSON.parse(JSON.stringify(task)); newTask.id = newId; newTasks.push(newTask); }); newTasks.forEach(task => { const oldPid = task.parentId; if (oldPid && idMap.has(oldPid)) { task.parentId = idMap.get(oldPid); } else { task.parentId = targetParentId; } task.dependencies.forEach(dep => { if (idMap.has(dep.id)) { dep.id = idMap.get(dep.id); } }); }); this.tasks.splice(targetIndex + 1, 0, ...newTasks); this.selectedTaskIds.clear(); newTasks.forEach(t => this.selectedTaskIds.add(t.id)); this.recalculateAll(); this.saveData(); this.render(); }
        initKeyboardShortcuts() { document.addEventListener('keydown', (e) => { const isEditing = e.target.classList.contains('cell-input'); const isCtrl = e.ctrlKey || e.metaKey; if (isCtrl && e.key === 'c' && !isEditing) { e.preventDefault(); this.copySelection(); return; } if (isCtrl && e.key === 'v' && !isEditing) { e.preventDefault(); this.pasteTasks(); return; } if (isCtrl && e.key === 'z' && !e.shiftKey) { e.preventDefault(); this.undo(); return; } if ((isCtrl && e.key === 'y') || (isCtrl && e.shiftKey && e.key === 'z')) { e.preventDefault(); this.redo(); return; } if (e.key === 'F2' && !isEditing && this.lastFocusedTaskId) { e.preventDefault(); this.enterEditMode(); return; } if (e.key === 'Insert' && !isEditing) { e.preventDefault(); this.insertTaskAbove(); return; } if (e.key === 'Enter' && isEditing) { e.target.blur(); return; } if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && isCtrl) { e.preventDefault(); this.moveTaskVertical(e.key === 'ArrowUp' ? -1 : 1); return; } if (e.key === 'Tab' && !isEditing && this.selectedTaskIds.size > 0) { e.preventDefault(); if (e.shiftKey) this.outdentSelection(); else this.indentSelection(); return; } if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && !e.ctrlKey && !isEditing) { e.preventDefault(); this.handleArrowNavigation(e.key === 'ArrowUp' ? -1 : 1, e.shiftKey); return; } if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && !isEditing && this.lastFocusedTaskId) { const task = this.tasks.find(t => t.id === this.lastFocusedTaskId); if (task && this.isParent(task.id)) { e.preventDefault(); if (e.key === 'ArrowRight' && task._collapsed) { task._collapsed = false; this.render(); } else if (e.key === 'ArrowLeft' && !task._collapsed) { task._collapsed = true; this.render(); } } return; } if (e.key === 'Escape') { if (isEditing) e.target.blur(); else if(document.getElementById('sideDrawer').classList.contains('open')) this.closeDrawer(); else this.deselectAll(); return; } if ((e.key === 'Delete' || e.key === 'Backspace') && !isEditing && this.selectedTaskIds.size > 0) { this.deleteSelectedTasks(); } }); }
        enterEditMode() { const row = document.querySelector(`.grid-row[data-id="${this.lastFocusedTaskId}"]`); if (!row) return; const input = row.querySelector('.cell-input'); if (input) { input.focus(); input.select(); } }
        insertTaskAbove() { this.saveCheckpoint(); if (!this.lastFocusedTaskId) { this.addTask(); return; } const targetIndex = this.tasks.findIndex(t => t.id === this.lastFocusedTaskId); if (targetIndex === -1) return; const targetTask = this.tasks[targetIndex]; const newId = Date.now().toString(); const today = new Date().toISOString().split('T')[0]; const newTask = { id: newId, name: "New Task", start: today, end: today, duration: 1, parentId: targetTask.parentId, dependencies: [], progress: 0, _collapsed: false }; this.tasks.splice(targetIndex, 0, newTask); this.recalculateAll(); this.saveData(); this.render(); this.lastFocusedTaskId = newId; this.selectedTaskIds.clear(); this.selectedTaskIds.add(newId); this.renderGrid(); this.scrollToRow(newId); }
        handleArrowNavigation(direction, isShift) { const visibleTasks = this.getFlatList().filter(t => this.isVisible(t.id)); if (visibleTasks.length === 0) return; let currentIndex = visibleTasks.findIndex(t => t.id === this.lastFocusedTaskId); if (currentIndex === -1) currentIndex = 0; let newIndex = currentIndex + direction; if (newIndex < 0) newIndex = 0; if (newIndex >= visibleTasks.length) newIndex = visibleTasks.length - 1; const targetTask = visibleTasks[newIndex]; this.lastFocusedTaskId = targetTask.id; if (!isShift) { this.anchorTaskId = targetTask.id; this.selectedTaskIds.clear(); this.selectedTaskIds.add(targetTask.id); } else { if (!this.anchorTaskId) this.anchorTaskId = visibleTasks[currentIndex].id; const anchorIndex = visibleTasks.findIndex(t => t.id === this.anchorTaskId); const start = Math.min(anchorIndex, newIndex); const end = Math.max(anchorIndex, newIndex); this.selectedTaskIds.clear(); for (let i = start; i <= end; i++) { this.selectedTaskIds.add(visibleTasks[i].id); } } this.renderGrid(); this.scrollToRow(targetTask.id); }
        handleRowClick(e, id) { if (e.target.classList.contains('cell-input') || e.target.closest('button')) return; const visibleTasks = this.getFlatList().filter(t => this.isVisible(t.id)); const clickedIndex = visibleTasks.findIndex(t => t.id === id); this.lastFocusedTaskId = id; if (e.shiftKey && this.anchorTaskId) { const anchorIndex = visibleTasks.findIndex(t => t.id === this.anchorTaskId); const start = Math.min(anchorIndex, clickedIndex); const end = Math.max(anchorIndex, clickedIndex); this.selectedTaskIds.clear(); for (let i = start; i <= end; i++) { this.selectedTaskIds.add(visibleTasks[i].id); } } else if (e.ctrlKey || e.metaKey) { if (this.selectedTaskIds.has(id)) this.selectedTaskIds.delete(id); else { this.selectedTaskIds.add(id); this.anchorTaskId = id; } } else { this.selectedTaskIds.clear(); this.selectedTaskIds.add(id); this.anchorTaskId = id; } this.renderGrid(); }
        scrollToRow(id) { const row = document.querySelector(`.grid-row[data-id="${id}"]`); if (row) row.scrollIntoView({ block: 'nearest', behavior: 'auto' }); }
        deselectAll() { this.selectedTaskIds.clear(); this.renderGrid(); }
        moveTaskVertical(direction) { if (!this.lastFocusedTaskId) return; this.saveCheckpoint(); const task = this.tasks.find(t => t.id === this.lastFocusedTaskId); if (!task) return; const siblings = this.tasks.filter(t => t.parentId === task.parentId); const currentSiblingIndex = siblings.findIndex(t => t.id === task.id); if (currentSiblingIndex === -1) return; const targetSiblingIndex = currentSiblingIndex + direction; if (targetSiblingIndex < 0 || targetSiblingIndex >= siblings.length) return; const siblingTarget = siblings[targetSiblingIndex]; const indexA = this.tasks.indexOf(task); const indexB = this.tasks.indexOf(siblingTarget); if (indexA > -1 && indexB > -1) { [this.tasks[indexA], this.tasks[indexB]] = [this.tasks[indexB], this.tasks[indexA]]; this.saveData(); this.render(); this.scrollToRow(this.lastFocusedTaskId); } }
        initScrollSync() { const grid = document.getElementById('grid-body'); const gantt = document.getElementById('ganttPane'); let isSyncingLeft = false; let isSyncingRight = false; grid.onscroll = function() { if (!isSyncingLeft) { isSyncingRight = true; gantt.scrollTop = this.scrollTop; } isSyncingLeft = false; }; gantt.onscroll = function() { if (!isSyncingRight) { isSyncingLeft = true; grid.scrollTop = this.scrollTop; } isSyncingRight = false; }; }
        initSortable() { const el = document.getElementById('grid-body'); if (typeof Sortable === 'undefined') return; this.sortable = Sortable.create(el, { animation: 150, handle: '.drag-handle', ghostClass: 'sortable-ghost', dragClass: 'sortable-drag', onEnd: (evt) => { const { oldIndex, newIndex } = evt; if (oldIndex === newIndex) return; this.saveCheckpoint(); this.render(); } }); }
        zoom(direction) { const idx = this.viewOptions.indexOf(this.viewMode); if (direction === 'in' && idx > 0) { this.changeView(this.viewOptions[idx - 1]); } else if (direction === 'out' && idx < this.viewOptions.length - 1) { this.changeView(this.viewOptions[idx + 1]); } }
        changeView(mode) { this.viewMode = mode; document.getElementById('zoom-label').innerText = mode; if(this.gantt) this.gantt.change_view_mode(mode); }
        openPopout() { const win = window.open('', 'ProLogicGantt', 'width=1200,height=800,menubar=no,toolbar=no'); if(!win) { alert('Popup blocked!'); return; } const tasksJson = JSON.stringify(this.tasks.filter(t => t.start && t.end && this.isVisible(t.id)).map(t => ({ id: t.id, name: t.name, start: t.start, end: t.end, progress: t.progress, dependencies: t.dependencies.map(d => d.id).join(", "), custom_class: (this.isParent(t.id) ? 'parent' : '') + (t._isCritical ? ' critical' : '') }))); const html = `<!DOCTYPE html><html><head><title>Pro Logic Detached</title><script src="https://cdnjs.cloudflare.com/ajax/libs/frappe-gantt/0.6.1/frappe-gantt.min.js"><\/script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/frappe-gantt/0.6.1/frappe-gantt.css"><style>body{font-family:sans-serif;padding:20px}.bar-wrapper.parent .bar{fill:#334155;height:10px;opacity:0.8}.bar-wrapper .bar{fill:#93c5fd}.bar-wrapper.critical .bar{fill:#f87171;stroke:#dc2626}</style></head><body><h3>Pro Logic Detached View</h3><svg id="gantt"></svg><script>new Gantt("#gantt", ${tasksJson}, {header_height:50,column_width:30,view_modes:['Day','Week','Month'],bar_height:20,view_mode:'Week'});<\/script></body></html>`; win.document.write(html); win.document.close(); }
        loadData() { const stored = localStorage.getItem('pro_v7_9_data'); if (stored) { this.tasks = JSON.parse(stored); } else { const fri = this.getNextDayOfWeek(5); this.tasks = [ { id: "1", name: "Structure Phase", start: "", end: "", duration: 0, parentId: null, dependencies: [], progress: 0, _collapsed: false }, { id: "2", name: "Framing", start: fri, end: "", duration: 3, parentId: "1", dependencies: [], progress: 0 }, { id: "3", name: "Sheathing", start: "", end: "", duration: 2, parentId: "1", dependencies: [{id: "2", type: "FS", lag: 0}], progress: 0 }, ]; } }
        saveData() { localStorage.setItem('pro_v7_9_data', JSON.stringify(this.tasks)); }
        addWorkDays(startDateStr, days) { if (!startDateStr) return ""; let date = new Date(startDateStr); const direction = days >= 0 ? 1 : -1; let remaining = Math.abs(days); while (remaining > 0) { date.setDate(date.getDate() + direction); const day = date.getDay(); if (day !== 0 && day !== 6) remaining--; } return date.toISOString().split('T')[0]; }
        calcDurationWorkDays(startStr, endStr) { if (!startStr || !endStr) return 0; let current = new Date(startStr); let end = new Date(endStr); if (current > end) return 0; let count = 0; while (current < end) { current.setDate(current.getDate() + 1); const day = current.getDay(); if (day !== 0 && day !== 6) count++; } return count; }
        getNextDayOfWeek(dayIndex) { const d = new Date(); d.setDate(d.getDate() + (7 + dayIndex - d.getDay()) % 7); return d.toISOString().split('T')[0]; }
        calcCriticalPath() { const validEnds = this.tasks.filter(t => t.end).map(t => t.end); const projectEnd = validEnds.sort().reverse()[0]; this.tasks.forEach(t => t._isCritical = false); if (projectEnd) { const mark = (task) => { if(task._isCritical) return; task._isCritical = true; task.dependencies.forEach(dep => { const pred = this.tasks.find(x => x.id === dep.id); if(pred) mark(pred); }); if (task.parentId) { const p = this.tasks.find(x => x.id === task.parentId); if(p) p._isCritical = true; } }; this.tasks.filter(t => t.end === projectEnd).forEach(t => mark(t)); } }
        isParent(id) { return this.tasks.some(t => t.parentId === id); }
        isVisible(taskId) { let curr = this.tasks.find(t => t.id === taskId); while (curr && curr.parentId) { const parent = this.tasks.find(p => p.id === curr.parentId); if (parent && parent._collapsed) return false; curr = parent; } return true; }
        render() { this.renderGrid(); this.renderGantt(); lucide.createIcons(); }
        renderGantt() { const validTasks = this.tasks.filter(t => t.start && t.end && this.isVisible(t.id)); const ganttData = validTasks.map(t => ({ id: t.id, name: t.name, start: t.start, end: t.end, progress: t.progress, dependencies: t.dependencies.map(d => d.id).join(", "), custom_class: (this.isParent(t.id) ? 'parent' : '') + (t._isCritical ? ' critical' : '') })); if(ganttData.length === 0) { document.getElementById('gantt-chart').innerHTML = '<div class="text-gray-400 text-xs p-4">No visible tasks</div>'; return; } if (!this.gantt) { this.gantt = new Gantt("#gantt-chart", ganttData, { header_height: 50, column_width: 30, step: 24, view_modes: ['Day', 'Week', 'Month'], bar_height: 20, bar_corner_radius: 3, arrow_curve: 5, padding: 18, view_mode: this.viewMode, date_format: 'YYYY-MM-DD', on_date_change: (task, start, end) => this.handleDrag(task, start, end) }); } else { this.gantt.refresh(ganttData); } }
        deleteTask(id) { this.saveCheckpoint(); const isParent = this.isParent(id); if (confirm(`Delete? ${isParent ? '(This will delete all children tasks)' : ''}`)) { let idsToRemove = [id]; if (isParent) { const getDescendants = (pid) => { this.tasks.filter(c => c.parentId === pid).forEach(c => { idsToRemove.push(c.id); getDescendants(c.id); }); }; getDescendants(id); } this.tasks = this.tasks.filter(t => !idsToRemove.includes(t.id)); this.tasks.forEach(t => { t.dependencies = t.dependencies.filter(d => !idsToRemove.includes(d.id)); }); idsToRemove.forEach(remId => this.selectedTaskIds.delete(remId)); this.recalculateAll(); this.saveData(); this.render(); } }
        deleteSelectedTasks() { this.saveCheckpoint(); if(confirm(`Delete ${this.selectedTaskIds.size} tasks?`)) { const ids = Array.from(this.selectedTaskIds); ids.forEach(id => { let idsToRemove = [id]; if (this.isParent(id)) { const getDescendants = (pid) => { this.tasks.filter(c => c.parentId === pid).forEach(c => { idsToRemove.push(c.id); getDescendants(c.id); }); }; getDescendants(id); } this.tasks = this.tasks.filter(t => !idsToRemove.includes(t.id)); this.tasks.forEach(t => { t.dependencies = t.dependencies.filter(d => !idsToRemove.includes(d.id)); }); }); this.selectedTaskIds.clear(); this.recalculateAll(); this.saveData(); this.render(); } }
        handleDrag(task, start, end) { this.saveCheckpoint(); const t = this.tasks.find(x => x.id === task.id); if (this.isParent(t.id)) { this.render(); return; } const startStr = start.toISOString().split('T')[0]; const endStr = end.toISOString().split('T')[0]; t.start = startStr; t.duration = this.calcDurationWorkDays(startStr, endStr); this.recalculateAll(); this.saveData(); this.renderGrid(); }
        addTask() { this.saveCheckpoint(); const id = Date.now().toString(); const today = new Date().toISOString().split('T')[0]; this.tasks.push({ id, name: "New Task", start: today, end: today, duration: 1, parentId: null, dependencies: [], progress: 0, _collapsed: false }); this.recalculateAll(); this.saveData(); this.render(); }
        getFlatList() { const res = []; const add = (pid) => this.tasks.filter(t => t.parentId === pid).forEach(t => { res.push(t); add(t.id); }); add(null); const knownIds = res.map(t => t.id); this.tasks.filter(t => !knownIds.includes(t.id)).forEach(t => { t.parentId = null; res.push(t); }); return res; }
        getDepth(id, d=0) { const t = this.tasks.find(x => x.id === id); return (t && t.parentId) ? this.getDepth(t.parentId, d+1) : d; }
        indent(id) { this.saveCheckpoint(); const list = this.getFlatList(); const idx = list.findIndex(t => t.id === id); if (idx <= 0) return; const task = list[idx]; const prev = list[idx - 1]; const taskDepth = this.getDepth(task.id); const prevDepth = this.getDepth(prev.id); if (prevDepth < taskDepth) return; let newParentId = null; if (prevDepth === taskDepth) { newParentId = prev.id; } else { let curr = prev; while (curr && this.getDepth(curr.id) > taskDepth) { curr = this.tasks.find(t => t.id === curr.parentId); } if (curr) newParentId = curr.id; } this.tasks.find(t => t.id === id).parentId = newParentId; this.recalculateAll(); this.saveData(); this.render(); }
        indentSelection() { this.saveCheckpoint(); const list = this.getFlatList(); const selectedIds = new Set(this.selectedTaskIds); const updates = new Map(); const sortedSelection = list.filter(t => selectedIds.has(t.id)); sortedSelection.forEach(task => { if (task.parentId && selectedIds.has(task.parentId)) return; const idx = list.findIndex(t => t.id === task.id); if (idx <= 0) return; const prev = list[idx - 1]; const taskDepth = this.getDepth(task.id); const prevDepth = this.getDepth(prev.id); if (prevDepth < taskDepth) return; let newParentId = null; if (prevDepth === taskDepth) { newParentId = prev.id; } else { let curr = prev; while(curr && this.getDepth(curr.id) > taskDepth) { const p = this.tasks.find(t => t.id === curr.parentId); curr = p; } if (curr) newParentId = curr.id; } updates.set(task.id, newParentId); }); if (updates.size > 0) { updates.forEach((newPid, taskId) => { this.tasks.find(t => t.id === taskId).parentId = newPid; }); this.recalculateAll(); this.saveData(); this.render(); } }
        outdent(id) { this.saveCheckpoint(); const t = this.tasks.find(t => t.id === id); if (t.parentId) { const parent = this.tasks.find(p => p.id === t.parentId); t.parentId = parent ? parent.parentId : null; this.recalculateAll(); this.saveData(); this.render(); } }
        outdentSelection() { this.saveCheckpoint(); const list = this.getFlatList(); const selectedIds = new Set(this.selectedTaskIds); const updates = new Map(); const sortedSelection = list.filter(t => selectedIds.has(t.id)); sortedSelection.forEach(task => { if (!task.parentId) return; if (!selectedIds.has(task.parentId)) { const currentParent = this.tasks.find(p => p.id === task.parentId); const newParentId = currentParent ? currentParent.parentId : null; updates.set(task.id, newParentId); } }); if (updates.size > 0) { updates.forEach((newPid, taskId) => { this.tasks.find(t => t.id === taskId).parentId = newPid; }); this.recalculateAll(); this.saveData(); this.render(); } }
        makeResizable() { const resizer = document.getElementById('resizer'); const leftSide = document.getElementById('gridPane'); let x = 0; let leftWidth = 0; const onMouseDown = (e) => { x = e.clientX; leftWidth = leftSide.getBoundingClientRect().width; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); resizer.classList.add('active'); document.body.style.userSelect = 'none'; document.body.style.cursor = 'col-resize'; }; const onMouseMove = (e) => { leftSide.style.width = `${leftWidth + e.clientX - x}px`; }; const onMouseUp = () => { resizer.classList.remove('active'); document.body.style.userSelect = ''; document.body.style.cursor = ''; document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); }; resizer.addEventListener('mousedown', onMouseDown); }
        startColResize(e, varName) { e.preventDefault(); e.stopPropagation(); const gridPane = document.getElementById('gridPane'); const startX = e.clientX; const startWidth = parseInt(getComputedStyle(gridPane).getPropertyValue(varName)); e.target.classList.add('active'); document.body.style.cursor = 'col-resize'; const onMouseMove = (moveEvent) => { const diff = moveEvent.clientX - startX; const newWidth = Math.max(30, startWidth + diff); gridPane.style.setProperty(varName, newWidth + 'px'); }; const onMouseUp = () => { e.target.classList.remove('active'); document.body.style.cursor = ''; document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onMouseUp); }; document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onMouseUp); }
        openLinks(id) { this.activeTaskId = id; const task = this.tasks.find(t => t.id === id); this.tempDependencies = JSON.parse(JSON.stringify(task.dependencies || [])); this.renderModal(); document.getElementById('linkModal').showModal(); }
        switchTab(tab) { document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active')); document.getElementById(`tab-${tab}`).classList.add('active'); document.getElementById('view-pred').classList.add('hidden'); document.getElementById('view-succ').classList.add('hidden'); document.getElementById(`view-${tab}`).classList.remove('hidden'); }
        renderModal() { const predBody = document.getElementById('pred-list-body'); predBody.innerHTML = ''; this.tempDependencies.forEach((dep, idx) => { const t = this.tasks.find(x => x.id === dep.id); if(!t) return; predBody.innerHTML += `<tr class="border-b border-gray-100 hover:bg-slate-50"><td class="p-2">${t.name}</td><td class="p-2"><select onchange="app.updateTempLink(${idx}, 'type', this.value)" class="border rounded p-1 text-xs w-full bg-white"><option value="FS" ${dep.type === 'FS' ? 'selected' : ''}>Finish to Start</option><option value="SS" ${dep.type === 'SS' ? 'selected' : ''}>Start to Start</option><option value="FF" ${dep.type === 'FF' ? 'selected' : ''}>Finish to Finish</option></select></td><td class="p-2"><input type="number" value="${dep.lag || 0}" onchange="app.updateTempLink(${idx}, 'lag', this.value)" class="border rounded p-1 w-16 text-xs text-center"></td><td class="p-2 text-center"><button onclick="app.removeTempLink(${idx})" class="text-red-400 hover:text-red-600"><i data-lucide="trash-2" class="w-3 h-3"></i></button></td></tr>`; }); const select = document.getElementById('new-pred-select'); select.innerHTML = '<option value="">Select task...</option>'; const existingIds = this.tempDependencies.map(d => d.id); this.tasks.filter(t => t.id !== this.activeTaskId && !existingIds.includes(t.id) && !this.isParent(t.id)).forEach(t => { select.innerHTML += `<option value="${t.id}">${t.name}</option>`; }); const succBody = document.getElementById('succ-list-body'); succBody.innerHTML = ''; const successors = this.tasks.filter(t => t.dependencies.some(d => d.id === this.activeTaskId)); if (successors.length === 0) succBody.innerHTML = `<tr><td colspan="3" class="p-4 text-center text-gray-400 italic">No successors found.</td></tr>`; else successors.forEach(succ => { const link = succ.dependencies.find(d => d.id === this.activeTaskId); succBody.innerHTML += `<tr class="border-b border-gray-100"><td class="p-2 font-medium">${succ.name}</td><td class="p-2 text-gray-600">${link.type}</td><td class="p-2 text-gray-600">${link.lag} days</td></tr>`; }); lucide.createIcons(); }
        addPredecessor() { const select = document.getElementById('new-pred-select'); const id = select.value; if (!id) return; this.tempDependencies.push({ id: id, type: 'FS', lag: 0 }); this.renderModal(); }
        removeTempLink(index) { this.tempDependencies.splice(index, 1); this.renderModal(); }
        updateTempLink(index, field, value) { if (field === 'lag') value = parseInt(value) || 0; this.tempDependencies[index][field] = value; }
        saveLinks() { this.saveCheckpoint(); const task = this.tasks.find(t => t.id === this.activeTaskId); task.dependencies = JSON.parse(JSON.stringify(this.tempDependencies)); document.getElementById('linkModal').close(); this.recalculateAll(); this.saveData(); this.render(); }
    }

    const app = new ProScheduler();
</script>
</body>
</html>